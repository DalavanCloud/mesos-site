<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Apache Mesos: Reconciliation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Mesos
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Reconciliation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>There's no getting around it, <b>frameworks on Mesos are distributed systems</b>.</p>
<p><b>Distributed systems must deal with failures</b> and partitions (the two are indistinguishable from a system's perspective).</p>
<p>Concretely, what does this mean for frameworks? Mesos uses an actor-like <b>message passing</b> programming model, in which messages are delivered <b>at-most-once</b>. (Exceptions to this include task status updates, most of which are delivered at-least-once through the use of acknowledgements). <b>The messages passed between the master and the framework are therefore susceptible to be dropped, in the presence of failures</b>.</p>
<p>When these unreliable messages are dropped, inconsistent state can arise between the framework and Mesos.</p>
<p>As a simple example, consider a launch task request sent by a framework. There are many ways that failures can lead to the loss of the task, for example:</p>
<ul>
<li>Framework fails after persisting its intent to launch the task, but before the launch task message was sent.</li>
<li>Master fails before receiving the message.</li>
<li>Master fails after receiving the message, but before sending it to the slave.</li>
</ul>
<p>In these cases, the framework believes the task to be staging, but the task is unknown to Mesos. To cope with such situations, <b>task state must be reconciled between the framework and Mesos whenever a failure is detected</b>.</p>
<h2>Detecting Failures</h2>
<p>It is the responsibility of Mesos (scheduler driver / Master) to ensure that the framework is notified when a disconnection, and subsequent (re-)registration occurs. At this point, the scheduler should perform task state reconciliation.</p>
<h2>Task Reconciliation</h2>
<p>Mesos provides two forms of reconciliation:</p>
<ul>
<li>"Explicit" reconciliation: the scheduler sends some of its non-terminal tasks and the master responds with the latest state for each task, if possible.</li>
<li>"Implicit" reconciliation: the scheduler sends an empty list of tasks and the master responds with the latest state for all currently known non-terminal tasks.</li>
</ul>
<p><b>Tasks must be reconciled explicitly by the framework after a failure.</b></p>
<p>This is because the scheduler driver does not persist any task information. In the future, the scheduler driver (or a pure-language mesos library) could perform task reconciliation seamlessly under the covers on behalf of the framework.</p>
<p>So, for now, let's look at how one needs to implement task state reconciliation in a framework scheduler.</p>
<h3>API</h3>
<p>Frameworks send a list of <code>TaskStatus</code> messages to the master: </p><pre class="fragment">// Allows the framework to query the status for non-terminal tasks.
// This causes the master to send back the latest task status for
// each task in 'statuses', if possible. Tasks that are no longer
// known will result in a TASK_LOST update. If statuses is empty,
// then the master will send the latest status for each task
// currently known.
message Reconcile {
  repeated TaskStatus statuses = 1; // Should be non-terminal only.
}
</pre><p>Currently, the master will only examine two fields in <code>TaskStatus</code>:</p>
<ul>
<li><code>TaskID</code>: This is required.</li>
<li><code>SlaveID</code>: Optional, leads to faster reconciliation in the presence of slaves that are transitioning between states.</li>
</ul>
<h3>Algorithm</h3>
<p>This technique for explicit reconciliation reconciles all non-terminal tasks, until an update is received for each task, using exponential backoff to retry tasks that remain unreconciled. Retries are needed because the master temporarily may not be able to reply for a particular task. For example, during master failover the master must re-register all of the slaves to rebuild its set of known tasks (this process can take minutes for large clusters, and is bounded by the <code>--slave_reregister_timeout</code> flag on the master).</p>
<p>Steps:</p>
<ol type="1">
<li>let <code>start = now()</code></li>
<li>let <code>remaining = { T in tasks | T is non-terminal }</code></li>
<li>Perform reconciliation: <code>reconcile(remaining)</code></li>
<li>Wait for status updates to arrive (use truncated exponential backoff). For each update, note the time of arrival.</li>
<li>let <code>remaining = { T in remaining | T.last_update_arrival() &lt; start }</code></li>
<li>If <code>remaining</code> is non-empty, go to 3.</li>
</ol>
<p>This reconciliation algorithm <b>must</b> be run after each (re-)registration.</p>
<p>Implicit reconciliation (passing an empty list) should also be used periodically, as a defense against data loss in the framework. Unless a strict registry is in use on the master, its possible for tasks to resurrect from a LOST state (without a strict registry the master does not enforce slave removal across failovers). When an unknown task is encountered, the scheduler should kill or recover the task.</p>
<p>Notes:</p>
<ul>
<li>When waiting for updates to arrive, <b>use a truncated exponential backoff</b>. This will avoid a snowball effect in the case of the driver or master being backed up.</li>
<li>It is beneficial to ensure that only 1 reconciliation is in progress at a time, to avoid a snowball effect in the face of many re-registrations. If another reconciliation should be started while one is in-progress, then the previous reconciliation algorithm should stop running.</li>
</ul>
<h2>Offer Reconciliation</h2>
<p>Offers are reconciled automatically after a failure:</p>
<ul>
<li>Offers do not persist beyond the lifetime of a Master.</li>
<li>If a disconnection occurs, offers are no longer valid.</li>
<li>Offers are rescinded and regenerated each time the framework (re-)registers. </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
