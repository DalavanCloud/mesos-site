<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Apache Mesos: testing-patterns</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Mesos
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">testing-patterns </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr/>
 <h2>layout: documentation </h2>
<h1>Mesos Testing Patterns</h1>
<p>A collection of common testing patterns used in Mesos tests. If you have found a good way to test a certain condition that you think may be useful for other cases, please document it here together with motivation and background.</p>
<h2>Expediting events with <code>Clock</code></h2>
<p>Some events in Mesos are separated by certain timeouts, for example framework registration attempts. Simple waiting for such events to fire leads to blocking the test thread for the duration of the associated timeout. This increases the duration of <code>make check</code> for no good reason.</p>
<p>If an event is triggered by an act of processing a message from an actor's mailbox, it can be expedited with the help of libprocess' <code>Clock</code> routines. Delayed messages are maintained in sorted order by their due time and are dispatched - i.e. pushed into destination mailboxes - when this time comes. An important bit here is that time is driven by the internal libprocess clock. We can shift this clock into the future by calling <code>Clock::advance(&lt;duration&gt;)</code>, rendering certain front messages in the collection due now. These messages are dispatched instantly, effectively overriding the associated event's timeout.</p>
<p><b>NOTE</b>: Without calling <code>Clock::settle()</code> there is no guarantee a dispatched message has been already processed.</p>
<p>Below is an example of this pattern. To avoid master backlogging, Mesos frameworks usually wait for some time (backoff) before retrying registration. In the test below we simulate the loss of a registration request, but avoid blocking the test for the backoff duration.</p>
<div class="fragment"><div class="line">TEST_F(FaultToleranceTest, FrameworkReliableRegistration)</div><div class="line">{</div><div class="line">  <a class="code" href="classTry.html">Try&lt;PID&lt;Master&gt;</a>&gt; master = StartMaster();</div><div class="line">  <a class="code" href="3rdparty_2stout_2include_2stout_2gtest_8hpp.html#ad6cfa825ea947ec3070622a5bd6fb9e0">ASSERT_SOME</a>(master);</div><div class="line"></div><div class="line">  <a class="code" href="classTry.html">Try&lt;PID&lt;Slave&gt;</a>&gt; slave = StartSlave();</div><div class="line">  <a class="code" href="3rdparty_2stout_2include_2stout_2gtest_8hpp.html#ad6cfa825ea947ec3070622a5bd6fb9e0">ASSERT_SOME</a>(slave);</div><div class="line"></div><div class="line">  <span class="comment">// As a side effect of driver instantiation, registration backoff will be set</span></div><div class="line">  <span class="comment">// to a default: internal::scheduler::REGISTRATION_BACKOFF_FACTOR.</span></div><div class="line">  MockScheduler <a class="code" href="namespacesched.html">sched</a>;</div><div class="line">  MesosSchedulerDriver driver(</div><div class="line">      &amp;sched, <a class="code" href="src_2tests_2mesos_8hpp.html#a9b232d1687a783c1ccd6bb5a09b695bb">DEFAULT_FRAMEWORK_INFO</a>, master.<a class="code" href="classTry.html#afb0e8411017a05b25bea3b851502886e">get</a>(), <a class="code" href="src_2tests_2mesos_8hpp.html#a8ce2d5ef94438df84d022911a1dfc223">DEFAULT_CREDENTIAL</a>);</div><div class="line"></div><div class="line">  Future&lt;Nothing&gt; registered;</div><div class="line">  EXPECT_CALL(sched, registered(&amp;driver, _, _))</div><div class="line">    .WillOnce(<a class="code" href="gmock_8hpp.html#a70c09011edb7b8656e8038c3f497eeb3">FutureSatisfy</a>(&amp;registered));</div><div class="line"></div><div class="line">  EXPECT_CALL(sched, resourceOffers(&amp;driver, _))</div><div class="line">    .WillRepeatedly(Return());</div><div class="line"></div><div class="line">  EXPECT_CALL(sched, offerRescinded(&amp;driver, _))</div><div class="line">    .Times(AtMost(1));</div><div class="line"></div><div class="line">  Future&lt;AuthenticateMessage&gt; authenticateMessage =</div><div class="line">    <a class="code" href="src_2tests_2mesos_8hpp.html#aee6552ee327ca7b95d109fc0f872d634">FUTURE_PROTOBUF</a>(AuthenticateMessage(), _, master.<a class="code" href="classTry.html#afb0e8411017a05b25bea3b851502886e">get</a>());</div><div class="line"></div><div class="line">  <span class="comment">// Drop the first framework registered message, allow subsequent messages.</span></div><div class="line">  Future&lt;FrameworkRegisteredMessage&gt; frameworkRegisteredMessage =</div><div class="line">    <a class="code" href="src_2tests_2mesos_8hpp.html#a16710d70a35a02690038d60b3e3da9d9">DROP_PROTOBUF</a>(FrameworkRegisteredMessage(), master.<a class="code" href="classTry.html#afb0e8411017a05b25bea3b851502886e">get</a>(), _);</div><div class="line"></div><div class="line">  driver.start();</div><div class="line"></div><div class="line">  <span class="comment">// Ensure authentication occurs.</span></div><div class="line">  <a class="code" href="include_2process_2gtest_8hpp.html#a40053e3b018990adc509382682c7c3cc">AWAIT_READY</a>(authenticateMessage);</div><div class="line"></div><div class="line">  <a class="code" href="include_2process_2gtest_8hpp.html#a40053e3b018990adc509382682c7c3cc">AWAIT_READY</a>(frameworkRegisteredMessage);</div><div class="line"></div><div class="line">  <span class="comment">// Trigger the registration retry instantly to avoid blocking the test.</span></div><div class="line">  Clock::pause();</div><div class="line">  Clock::advance(internal::scheduler::REGISTRATION_BACKOFF_FACTOR);</div><div class="line"></div><div class="line">  <a class="code" href="include_2process_2gtest_8hpp.html#a40053e3b018990adc509382682c7c3cc">AWAIT_READY</a>(registered); <span class="comment">// Ensures registered message is received.</span></div><div class="line"></div><div class="line">  driver.stop();</div><div class="line">  driver.join();</div><div class="line"></div><div class="line">  Shutdown();</div><div class="line"></div><div class="line">  Clock::resume();</div><div class="line">}</div></div><!-- fragment --><h2>Using <code>Clock</code> magic to ensure an event is processed</h2>
<p>Scheduling a sequence of events in an asynchronous environment is not easy: a function call usually initiates an action and returns immediately, while the action runs in background. A simple, obvious, and bad solution is to use <code><a class="el" href="namespaceos.html#a82694b52e4ebc14bcf548499395bdd53">os::sleep()</a></code> to wait for action completion. The time the action needs to finish may vary on different machines, while increasing sleep duration increases the test execution time and slows down <code>make check</code>. One of the right ways to do it is to wait for an action to finish and proceed right after. This is possible using libprocess' <code>Clock</code> routines.</p>
<p>Every message enqueued in a libprocess process' (or actor's, to avoid ambiguity with OS processes) mailbox is processed by <code>ProcessManager</code> (right now there is a single instance of <code>ProcessManager</code> per OS process, but this may change in the future). <code>ProcessManager</code> fetches actors from the runnable actors list and services all events from the actor's mailbox. Using <code>Clock::settle()</code> call we can block the calling thread until <code>ProcessManager</code> empties mailboxes of all actors. Here is the example of this pattern:</p>
<div class="fragment"><div class="line"><span class="comment">// As Master::killTask isn&#39;t doing anything, we shouldn&#39;t get a status update.</span></div><div class="line">EXPECT_CALL(sched, statusUpdate(&amp;driver, _))</div><div class="line">  .Times(0);</div><div class="line"></div><div class="line"><span class="comment">// Set expectation that Master receives killTask message.</span></div><div class="line">Future&lt;KillTaskMessage&gt; killTaskMessage =</div><div class="line">  <a class="code" href="src_2tests_2mesos_8hpp.html#aee6552ee327ca7b95d109fc0f872d634">FUTURE_PROTOBUF</a>(KillTaskMessage(), _, master.<a class="code" href="classTry.html#afb0e8411017a05b25bea3b851502886e">get</a>());</div><div class="line"></div><div class="line"><span class="comment">// Attempt to kill unknown task while slave is transitioning.</span></div><div class="line">TaskID unknownTaskId;</div><div class="line">unknownTaskId.set_value(<span class="stringliteral">&quot;2&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Stop the clock.</span></div><div class="line">Clock::pause();</div><div class="line"></div><div class="line"><span class="comment">// Initiate an action.</span></div><div class="line">driver.killTask(unknownTaskId);</div><div class="line"></div><div class="line"><span class="comment">// Make sure the event associated with the action has been queued.</span></div><div class="line"><a class="code" href="include_2process_2gtest_8hpp.html#a40053e3b018990adc509382682c7c3cc">AWAIT_READY</a>(killTaskMessage);</div><div class="line"></div><div class="line"><span class="comment">// Wait for all messages to be dispatched and processed completely to satisfy</span></div><div class="line"><span class="comment">// the expectation that we didn&#39;t receive a status update.</span></div><div class="line">Clock::settle();</div><div class="line"></div><div class="line">Clock::resume();</div></div><!-- fragment --><h2>Intercepting a message sent to a different OS process</h2>
<p>Intercepting messages sent between libprocess processes (let's call them actors to avoid ambiguity with OS processes) that live in the same OS process is easy, e.g.:</p>
<div class="fragment"><div class="line">Future&lt;SlaveReregisteredMessage&gt; slaveReregisteredMessage =</div><div class="line">  <a class="code" href="src_2tests_2mesos_8hpp.html#aee6552ee327ca7b95d109fc0f872d634">FUTURE_PROTOBUF</a>(SlaveReregisteredMessage(), _, _);</div><div class="line">...</div><div class="line">AWAIT_READY(slaveReregisteredMessage);</div></div><!-- fragment --><p>However, this won't work if we want to intercept a message sent to an actor (technically a <code>UPID</code>) that lives in another OS process. For example, <code>CommandExecutor</code> spawned by a slave will live in a separate OS process, though master and slave instances live in the same OS process together with our test (see <code>mesos/src/tests/cluster.hpp</code>). The wait in this code will fail:</p>
<div class="fragment"><div class="line">Future&lt;ExecutorRegisteredMessage&gt; executorRegisteredMessage =</div><div class="line">  <a class="code" href="src_2tests_2mesos_8hpp.html#aee6552ee327ca7b95d109fc0f872d634">FUTURE_PROTOBUF</a>(ExecutorRegisteredMessage(), _, _);</div><div class="line">...</div><div class="line">AWAIT_READY(executorRegisteredMessage);</div></div><!-- fragment --><h3>Why messages sent outside the OS process are not intercepted?</h3>
<p>Libprocess events may be filtered (see <code><a class="el" href="3rdparty_2libprocess_2include_2process_2filter_8hpp.html">libprocess/include/process/filter.hpp</a></code>). <code>FUTURE_PROTOBUF</code> uses this ability and sets an expectation on a <code>filter</code> method of <code>TestsFilter</code> class with a <code>MessageMatcher</code>, that matches the message we want to intercept. The actual filtering happens in <code>ProcessManager::resume()</code>, which fetches messages from the queue of the received events.</p>
<p><em>No</em> filtering happens when sending, encoding, or transporting the message (see e.g. <code>ProcessManager::deliver()</code> or <code>SocketManager::send()</code>). Therefore in the aforementioned example, <code>ExecutorRegisteredMessage</code> leaves the slave undetected by the filter, reaches another OS process where executor lives, gets enqueued into the <code>CommandExecutorProcess</code>' mailbox and can be filtered there, but remember our expectation is set in another OS process!</p>
<h3>How to workaround</h3>
<p>Consider setting expectations on corresponding incoming messages ensuring they are processed and therefore ACK message is sent.</p>
<p>For the aforementioned example, instead of intercepting <code>ExecutorRegisteredMessage</code>, we can intercept <code>RegisterExecutorMessage</code> and wait until its processed, which includes sending <code>ExecutorRegisteredMessage</code> (see <code>Slave::registerExecutor()</code>):</p>
<div class="fragment"><div class="line">Future&lt;RegisterExecutorMessage&gt; registerExecutorMessage =</div><div class="line">  <a class="code" href="src_2tests_2mesos_8hpp.html#aee6552ee327ca7b95d109fc0f872d634">FUTURE_PROTOBUF</a>(RegisterExecutorMessage(), _, _);</div><div class="line">...</div><div class="line">AWAIT_READY(registerExecutorMessage);</div><div class="line">Clock::pause();</div><div class="line">Clock::settle();</div><div class="line">Clock::resume();</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
