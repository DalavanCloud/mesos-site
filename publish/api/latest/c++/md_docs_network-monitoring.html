<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Apache Mesos: network-monitoring</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Mesos
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">network-monitoring </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr/>
 <h2>layout: documentation </h2>
<h1>Per-container <a class="el" href="classNetwork.html">Network</a> Monitoring and Isolation</h1>
<p>Mesos on Linux provides support for per-container network monitoring and isolation. The network isolation prevents a single container from exhausting the available network ports, consuming an unfair share of the network bandwidth or significantly delaying packet transmission for others. <a class="el" href="classNetwork.html">Network</a> statistics for each active container are published through the <code>/monitor/statistics.json</code> endpoint on the slave. The network isolation is transparent for the majority of tasks running on a slave (those that bind to port 0 and let the kernel allocate their port).</p>
<h2>Installation</h2>
<p>Per-container network monitoring and isolation is <b>not</b> supported by default. To enable it you need to install additional dependencies and configure it during the build process.</p>
<h3>Prerequisites</h3>
<p>Per-container network monitoring and isolation is only supported on Linux kernel versions 3.6 and above. Additionally, the kernel must include these patches (merged in kernel version 3.15).</p>
<ul>
<li><a href="https://github.com/torvalds/linux/commit/6a662719c9868b3d6c7d26b3a085f0cd3cc15e64">6a662719c9868b3d6c7d26b3a085f0cd3cc15e64</a></li>
<li><a href="https://github.com/torvalds/linux/commit/0d5edc68739f1c1e0519acbea1d3f0c1882a15d7">0d5edc68739f1c1e0519acbea1d3f0c1882a15d7</a></li>
<li><a href="https://github.com/torvalds/linux/commit/e374c618b1465f0292047a9f4c244bd71ab5f1f0">e374c618b1465f0292047a9f4c244bd71ab5f1f0</a></li>
<li><a href="https://github.com/torvalds/linux/commit/25f929fbff0d1bcebf2e92656d33025cd330cbf8">25f929fbff0d1bcebf2e92656d33025cd330cbf8</a></li>
</ul>
<p>The following packages are required on the slave:</p>
<ul>
<li><a href="http://www.infradead.org/~tgr/libnl/">libnl3</a> &gt;= 3.2.26</li>
<li><a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/iproute2">iproute</a> &gt;= 2.6.39 is advised for debugging purpose but not required.</li>
</ul>
<p>Additionally, if you are building from source, you need will also need the libnl3 development package to compile Mesos:</p>
<ul>
<li><a href="http://www.infradead.org/~tgr/libnl/">libnl3-devel / libnl3-dev</a> &gt;= 3.2.26</li>
</ul>
<h3>Build</h3>
<p>To build Mesos with per-container network monitoring and isolation support, you need to add a configure option: </p><pre class="fragment">$ ./configure --with-network-isolator
$ make
</pre><h2>Configuration</h2>
<p>Per-container network monitoring and isolation is enabled on the slave by adding <code>network/port_mapping</code> to the slave command line <code>--isolation</code> flag. </p><pre class="fragment">--isolation="network/port_mapping"
</pre><p>If the slave has not been compiled with per-container network monitoring and isolation support, it will refuse to start and print an error: </p><pre class="fragment">I0708 00:17:08.080271 44267 containerizer.cpp:111] Using isolation: network/port_mapping
Failed to create a containerizer: Could not create MesosContainerizer: Unknown or unsupported
    isolator: network/port_mapping
</pre><h2>Configuring network ports</h2>
<p>Without network isolation, all the containers on a host share the public IP address of the slave and can bind to any port allowed by the OS.</p>
<p>When network isolation is enabled, each container on the slave has a separate network stack (via Linux <a href="http://lwn.net/Articles/580893/">network namespaces</a>). All containers still share the same public IP of the slave (so that the service discovery mechanism does not need to be changed). The slave assigns each container a non-overlapping range of the ports and only packets to/from these assigned port ranges will be delivered. Applications requesting the kernel assign a port (by binding to port 0) will be given ports from the container assigned range. Applications can bind to ports outside the container assigned ranges but packets from to/from these ports will be silently dropped by the host.</p>
<p>Mesos provides two ranges of ports to containers:</p>
<ul>
<li>OS allocated "[ephemeral](https://en.wikipedia.org/wiki/Ephemeral_port)" ports are assigned by the OS in a range specified for each container by Mesos.</li>
<li>Mesos allocated "non-ephemeral" ports are acquired by a framework using the same Mesos resource offer mechanism used for cpu, memory etc. for allocation to executors/tasks as required.</li>
</ul>
<p>Additionally, the host itself will require ephemeral ports for network communication. You need to configure these three <b>non-overlapping</b> port ranges on the host.</p>
<h3>Host ephemeral port range</h3>
<p>The currently configured host ephemeral port range can be discovered at any time using the command <code>sysctl net.ipv4.ip_local_port_range</code>. If ports need to be set aside for slave containers, the ephemeral port range can be updated in <code>/etc/sysctl.conf</code>. Rebooting after the update will apply the change and eliminate the possibility that ports are already in use by other processes. For example, by adding the following: </p><pre class="fragment"># net.ipv4.ip_local_port_range defines the host ephemeral port range, by
# default 32768-61000.  We reduce this range to allow the Mesos slave to
# allocate ports 32768-57344
# net.ipv4.ip_local_port_range = 32768 61000
net.ipv4.ip_local_port_range = 57345 61000
</pre><h3>Container port ranges</h3>
<p>The container ephemeral and non-ephemeral port ranges are configured using the slave <code>--resources</code> flag. The non-ephemeral port range is provided to the master, which will then offer it to frameworks for allocation.</p>
<p>The ephemeral port range is sub-divided by the slave, giving <code>ephemeral_ports_per_container</code> (default 1024) to each container. The maximum number of containers on the slave will therefore be limited to approximately: </p><pre class="fragment">number of ephemeral_ports / ephemeral_ports_per_container
</pre><p>The master <code>--max_executors_per_slave</code> flag is be used to prevent allocation of more executors on a slave when the ephemeral port range has been exhausted.</p>
<p>It is recommended (but not required) that <code>ephemeral_ports_per_container</code> be set to a power of 2 (e.g., 512, 1024) and the lower bound of the ephemeral port range be a multiple of <code>ephemeral_ports_per_container</code> to minimize CPU overhead in packet processing. For example: </p><pre class="fragment">--resources=ports:[31000-32000];ephemeral_ports:[32768-57344] \
--ephemeral_ports_per_container=512
</pre><h3>Rate limiting container traffic</h3>
<p>Outbound traffic from a container to the network can be rate limited to prevent a single container from consuming all available network resources with detrimental effects to the other containers on the host. The <code>--egress_rate_limit_per_container</code> flag specifies that each container launched on the host be limited to the specified bandwidth (in bytes per second). <a class="el" href="classNetwork.html">Network</a> traffic which would cause this limit to be exceeded is delayed for later transmission. The TCP protocol will adjust to the increased latency and reduce the transmission rate ensuring no packets need be dropped. </p><pre class="fragment">--egress_rate_limit_per_container=100MB
</pre><p>We do not rate limit inbound traffic since we can only modify the network flows after they have been received by the host and any congestion has already occurred.</p>
<h3>Egress traffic isolation</h3>
<p>Delaying network data for later transmission can increase latency and jitter (variability) for all traffic on the interface. Mesos can reduce the impact on other containers on the same host by using flow classification and isolation using the containers port ranges to maintain unique flows for each container and sending traffic from these flows fairly (using the <a href="https://tools.ietf.org/html/draft-hoeiland-joergensen-aqm-fq-codel-00">FQ_Codel</a> algorithm). Use the <code>--egress_unique_flow_per_container</code> flag to enable. </p><pre class="fragment">--egress_unique_flow_per_container
</pre><h3>Putting it all together</h3>
<p>A complete slave command line enabling network isolation, reserving ports 57345-61000 for host ephemeral ports, 32768-57344 for container ephemeral ports, 31000-32000 for non-ephemeral ports allocated by the framework, limiting container transmit bandwidth to 300 Mbits/second (37.5MBytes) with unique flows enabled would thus be: </p><pre class="fragment">mesos-slave \
--isolation=network/port_mapping \
--resources=ports:[31000-32000];ephemeral_ports:[32768-57344] \
--ephemeral_ports_per_container=1024 \
--egress_rate_limit_per_container=37500KB \
--egress_unique_flow_per_container
</pre><h2>Monitoring container network statistics</h2>
<p>Mesos exposes statistics from the Linux network stack for each container network on the <code>/monitor/statistics.json</code> slave endpoint.</p>
<p>From the network interface inside the container, we report the following counters (since container creation) under the <code>statistics</code> key:</p>
<table  class="table table-striped">
</table>
<p>Metric</p>
<p>Description</p>
<p>Type &lt;/thead&gt; </p>
<p><code>net_rx_bytes</code> </p>
<p>Received bytes </p>
<p>Counter  </p>
<p><code>net_rx_dropped</code> </p>
<p>Packets dropped on receive </p>
<p>Counter  </p>
<p><code>net_rx_errors</code> </p>
<p>Errors reported on receive </p>
<p>Counter  </p>
<p><code>net_rx_packets</code> </p>
<p>Packets received </p>
<p>Counter  </p>
<p><code>net_tx_bytes</code> </p>
<p>Sent bytes </p>
<p>Counter  </p>
<p><code>net_tx_dropped</code> </p>
<p>Packets dropped on send </p>
<p>Counter  </p>
<p><code>net_tx_errors</code> </p>
<p>Errors reported on send </p>
<p>Counter  </p>
<p><code>net_tx_packets</code> </p>
<p>Packets sent </p>
<p>Counter  </p>
<p>Additionally, <a href="http://tldp.org/HOWTO/Traffic-Control-HOWTO/intro.html">Linux Traffic Control</a> can report the following statistics for the elements which implement bandwidth limiting and bloat reduction under the <code>statistics/net_traffic_control_statistics</code> key. The entry for each of these elements includes:</p>
<table  class="table table-striped">
</table>
<p>Metric</p>
<p>Description</p>
<p>Type &lt;/thead&gt; </p>
<p><code>backlog</code> </p>
<p><a class="el" href="classBytes.html">Bytes</a> queued for transmission [1] </p>
<p>Gauge  </p>
<p><code>bytes</code> </p>
<p>Sent bytes </p>
<p>Counter  </p>
<p><code>drops</code> </p>
<p>Packets dropped on send </p>
<p>Counter  </p>
<p><code>overlimits</code> </p>
<p>Count of times the interface was over its transmit limit when it attempted to send a packet. Since the normal action when the network is overlimit is to delay the packet, the overlimit counter can be incremented many times for each packet sent on a heavily congested interface. [2] </p>
<p>Counter  </p>
<p><code>packets</code> </p>
<p>Packets sent </p>
<p>Counter  </p>
<p><code>qlen</code> </p>
<p>Packets queued for transmission </p>
<p>Gauge  </p>
<p><code>ratebps</code> </p>
<p>Transmit rate in bytes/second [3] </p>
<p>Gauge  </p>
<p><code>ratepps</code> </p>
<p>Transmit rate in packets/second [3] </p>
<p>Gauge  </p>
<p><code>requeues</code> </p>
<p>Packets failed to send due to resource contention (such as kernel locking) [3] </p>
<p>Counter  </p>
<p>[1] <code>backlog</code> is only reported on the bloat_reduction interface</p>
<p>[2] <code>overlimits</code> are only reported on the bw_limit interface</p>
<p>[3] Currently always reported as 0 by the underlying Traffic Control element.</p>
<p>For example, these are the statistics you will get by hitting the <code>/monitor/statistics</code> endpoint on a slave with network monitoring turned on: </p><pre class="fragment">$ curl -s http://localhost:5051/monitor/statistics | python2.6 -mjson.tool
[
    {
        "executor_id": "job.1436298853",
        "executor_name": "Command Executor (Task: job.1436298853) (Command: sh -c 'iperf ....')",
        "framework_id": "20150707-195256-1740121354-5150-29801-0000",
        "source": "job.1436298853",
        "statistics": {
            "cpus_limit": 1.1,
            "cpus_nr_periods": 16314,
            "cpus_nr_throttled": 16313,
            "cpus_system_time_secs": 2667.06,
            "cpus_throttled_time_secs": 8036.840845388,
            "cpus_user_time_secs": 123.49,
            "mem_anon_bytes": 8388608,
            "mem_cache_bytes": 16384,
            "mem_critical_pressure_counter": 0,
            "mem_file_bytes": 16384,
            "mem_limit_bytes": 167772160,
            "mem_low_pressure_counter": 0,
            "mem_mapped_file_bytes": 0,
            "mem_medium_pressure_counter": 0,
            "mem_rss_bytes": 8388608,
            "mem_total_bytes": 9945088,
            "net_rx_bytes": 10847,
            "net_rx_dropped": 0,
            "net_rx_errors": 0,
            "net_rx_packets": 143,
            "net_traffic_control_statistics": [
                {
                    "backlog": 0,
                    "bytes": 163206809152,
                    "drops": 77147,
                    "id": "bw_limit",
                    "overlimits": 210693719,
                    "packets": 107941027,
                    "qlen": 10236,
                    "ratebps": 0,
                    "ratepps": 0,
                    "requeues": 0
                },
                {
                    "backlog": 15481368,
                    "bytes": 163206874168,
                    "drops": 27081494,
                    "id": "bloat_reduction",
                    "overlimits": 0,
                    "packets": 107941070,
                    "qlen": 10239,
                    "ratebps": 0,
                    "ratepps": 0,
                    "requeues": 0
                }
            ],
            "net_tx_bytes": 163200529816,
            "net_tx_dropped": 0,
            "net_tx_errors": 0,
            "net_tx_packets": 107936874,
            "perf": {
                "duration": 0,
                "timestamp": 1436298855.82807
            },
            "timestamp": 1436300487.41595
        }
    }
]</pre> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
