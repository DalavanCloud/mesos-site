<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Apache Mesos: Stout Developer Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Mesos
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Stout Developer Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Stout is a header-only C++ library. Simply add the <code>include</code> folder to your include path (i.e., <code>-I/path/to/stout/include</code>) during compilation (eventually we plan to support installation).</p>
<blockquote class="doxtable">
<p>NOTE: Depending on which headers you'd like to use, you may require the following third party libraries:</p>
<ul>
<li>Boost</li>
<li>Google's glog (this dependency will be removed in the future)</li>
<li>Google's protobuf (version 2.5.0 is required to run tests)</li>
<li>Google's gmock/gtest </li>
</ul>
</blockquote>
<p>There are a handful of data structures provided within the library (including some collections), as well as some namespaced and miscellaneous utilities. Also included are abstractions for <a href="#flags">command line flags</a>.</p>
<p>Stout provides and heavily leverages some monadic structures including <a href="#option">Option</a> and <a href="#try">Try</a>.</p>
<p>Note that the library is designed to completely avoid exceptions. See <a href="#exceptions">exceptions</a> for further discussion.</p>
<ul>
<li><a href="#option">Option, Some, and None</a></li>
<li><a href="#try">Try, Result, and Error</a></li>
<li><a href="#nothing">Nothing</a></li>
<li><a href="#fs">fs::</a></li>
<li><a href="#gzip">gzip::</a></li>
<li><a href="#json">JSON::</a></li>
<li><a href="#jsonify"><code>jsonify</code></a></li>
<li><a href="#lambda">lambda::</a></li>
<li><a href="#net">net::</a></li>
<li><a href="#os">os::</a></li>
<li><a href="#path">path::</a></li>
<li><a href="#proc">proc::</a></li>
<li><a href="#protobuf">protobuf::</a></li>
<li><a href="#strings">strings::</a></li>
<li><a href="#flags">Command Line Flags</a></li>
<li><a href="#collections">Collections</a></li>
<li><a href="#miscellaneous">Miscellaneous</a></li>
<li><a href="#testing">Testing</a></li>
<li><a href="#philosophy">Philosophy</a></li>
</ul>
<p><a href="option"></a></p>
<h2><code><a class="el" href="classOption.html">Option</a></code>, <code>Some</code>, and <code><a class="el" href="structNone.html">None</a></code></h2>
<p>The <code><a class="el" href="classOption.html">Option</a></code> type provides a safe alternative to using <code>NULL</code>. An <code><a class="el" href="classOption.html">Option</a></code> can be constructed explicitely or implicitely:</p>
<div class="fragment"><div class="line"><a class="code" href="classOption.html">Option&lt;bool&gt;</a> o(<span class="keyword">true</span>);</div><div class="line"><a class="code" href="classOption.html">Option&lt;bool&gt;</a> o = <span class="keyword">true</span>;</div></div><!-- fragment --><p>You can check if a value is present using <code><a class="el" href="classOption.html#a4e3bf8416d95246f43c91f1b5c309323">Option::isSome()</a></code> and <code><a class="el" href="classOption.html#a06eab791122ebc1f8af4ad310e5e7d7e">Option::isNone()</a></code> and retrieve the value using <code><a class="el" href="classOption.html#ac59d895c36d283eb26e4047299dff61b">Option::get()</a></code>:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!o.<a class="code" href="classOption.html#a06eab791122ebc1f8af4ad310e5e7d7e">isNone</a>()) {</div><div class="line">  ... o.<a class="code" href="classOption.html#a21358442c0fac1cc978a67a9a9089a79">get</a>() ...</div><div class="line">}</div></div><!-- fragment --><p>Note that the current implementation <em>copies</em> the underlying values (see <a href="#philosophy">Philosophy</a> for more discussion). <a class="el" href="structNothing.html">Nothing</a> prevents you from using pointers, however, <em>the pointer will not be deleted when the <a class="el" href="classOption.html">Option</a> is destructed</em>:</p>
<div class="fragment"><div class="line"><a class="code" href="classOption.html">Option&lt;std::string*&gt;</a> o = <span class="keyword">new</span> std::string(<span class="stringliteral">&quot;hello world&quot;</span>);</div></div><!-- fragment --><p>The <code><a class="el" href="structNone.html">None</a></code> type acts as "syntactic sugar" to make using <a href="#option">Option</a> less verbose. For example:</p>
<div class="fragment"><div class="line"><a class="code" href="classOption.html">Option&lt;T&gt;</a> foo(<span class="keyword">const</span> <a class="code" href="classOption.html">Option&lt;T&gt;</a>&amp; o)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="structNone.html">None</a>(); <span class="comment">// Can use &#39;None&#39; here.</span></div><div class="line">}</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">foo(<a class="code" href="structNone.html">None</a>()); <span class="comment">// Or here.</span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">Option&lt;<span class="keywordtype">int</span>&gt; o = <a class="code" href="structNone.html">None</a>(); <span class="comment">// Or here.</span></div></div><!-- fragment --><p>Similar to <code><a class="el" href="structNone.html">None</a></code>, the <code>Some</code> type can be used to construct an <code><a class="el" href="classOption.html">Option</a></code> as well. In most circumstances <code>Some</code> is unnecessary due to the implicit <code><a class="el" href="classOption.html">Option</a></code> constructor, however, it can still be useful to remove any ambiguities as well as when embedded within collections:</p>
<div class="fragment"><div class="line"><a class="code" href="classOption.html">Option&lt;Option&lt;std::string&gt;</a>&gt; o = <a class="code" href="some_8hpp.html#a2048f5c3b4ee79448c012cf6dc82a020">Some</a>(<span class="stringliteral">&quot;42&quot;</span>);</div><div class="line"></div><div class="line">std::map&lt;std::string, Option&lt;std::string&gt;&gt; values;</div><div class="line">values[<span class="stringliteral">&quot;value1&quot;</span>] = <a class="code" href="structNone.html">None</a>();</div><div class="line">values[<span class="stringliteral">&quot;value2&quot;</span>] = <a class="code" href="some_8hpp.html#a2048f5c3b4ee79448c012cf6dc82a020">Some</a>(<span class="stringliteral">&quot;42&quot;</span>);</div></div><!-- fragment --><p><a href="try"></a></p>
<h2><code><a class="el" href="classTry.html">Try</a></code>, <code><a class="el" href="classResult.html">Result</a></code>, and <code><a class="el" href="classError.html">Error</a></code></h2>
<p>A <code><a class="el" href="classTry.html">Try</a></code> provides a mechanism to return a value or an error without throwing exceptions. Like <code><a class="el" href="classOption.html">Option</a></code>, you can explicitely or implicitely construct a <code><a class="el" href="classTry.html">Try</a></code>:</p>
<div class="fragment"><div class="line"><a class="code" href="classTry.html">Try&lt;bool&gt;</a> t(<span class="keyword">true</span>);</div><div class="line"><a class="code" href="classTry.html">Try&lt;bool&gt;</a> t = <span class="keyword">true</span>;</div></div><!-- fragment --><p>You can check if a value is present using <code><a class="el" href="classTry.html#af445dc5001bc01cfc86a8df5df79a29b">Try::isSome()</a></code> and <code><a class="el" href="classTry.html#a2e52c7006437d2cf421b373f75e3c767">Try::isError()</a></code> and retrieve the value using <code><a class="el" href="classTry.html#a865ab8d2b00896e69f1c247e08339b30">Try::get()</a></code> or the error via <code><a class="el" href="classTry.html#a177038e5012bde890795ee82d3986380">Try::error</a></code>:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!t.<a class="code" href="classTry.html#a2e52c7006437d2cf421b373f75e3c767">isError</a>()) {</div><div class="line">  ... t.<a class="code" href="classTry.html#afb0e8411017a05b25bea3b851502886e">get</a>() ...</div><div class="line">} <span class="keywordflow">else</span> {</div><div class="line">  ... t.<a class="code" href="classTry.html#a177038e5012bde890795ee82d3986380">error</a>() ...</div><div class="line">}</div></div><!-- fragment --><p>A <code><a class="el" href="classResult.html">Result</a></code> is a combination of a <code><a class="el" href="classTry.html">Try</a></code> and an <code><a class="el" href="classOption.html">Option</a></code>; you can think of a <code><a class="el" href="classResult.html">Result</a></code> as semantically being equivalant to <code><a class="el" href="classTry.html">Try</a>&lt;<a class="el" href="classOption.html">Option</a>&lt;T&gt;&gt;</code>. In addition to <code>isSome()</code> and <code>isError()</code> a <code><a class="el" href="classResult.html">Result</a></code> includes <code>isNone()</code>.</p>
<p>The <code><a class="el" href="classError.html">Error</a></code> type acts as "syntactic sugar" for implicitly constructing a <code><a class="el" href="classTry.html">Try</a></code> or <code><a class="el" href="classResult.html">Result</a></code>. For example:</p>
<div class="fragment"><div class="line"><a class="code" href="classTry.html">Try&lt;bool&gt;</a> <a class="code" href="namespacedocker_1_1spec_1_1v1.html#a53df9e5037db285426b2b18fec29b6c1">parse</a>(<span class="keyword">const</span> std::string&amp; s)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;true&quot;</span>) {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s == <span class="stringliteral">&quot;false&quot;</span>) {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">  } <span class="keywordflow">else</span> {</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="classError.html">Error</a>(<span class="stringliteral">&quot;Failed to parse string as boolean&quot;</span>);</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="classTry.html">Try&lt;bool&gt;</a> t = <a class="code" href="namespacedocker_1_1spec_1_1v1.html#a53df9e5037db285426b2b18fec29b6c1">parse</a>(<span class="stringliteral">&quot;false&quot;</span>);</div></div><!-- fragment --><p>You can also use <code><a class="el" href="structNone.html">None</a></code> and <code>Some</code> with <code><a class="el" href="classResult.html">Result</a></code> just like with <code><a class="el" href="classOption.html">Option</a></code>:</p>
<div class="fragment"><div class="line"><a class="code" href="classResult.html">Result&lt;bool&gt;</a> r = <a class="code" href="structNone.html">None</a>();</div><div class="line"><a class="code" href="classResult.html">Result&lt;bool&gt;</a> r = <a class="code" href="some_8hpp.html#a2048f5c3b4ee79448c012cf6dc82a020">Some</a>(<span class="keyword">true</span>);</div></div><!-- fragment --><p><a href="nothing"></a></p>
<h2><code><a class="el" href="structNothing.html">Nothing</a></code></h2>
<p>A lot of functions that return <code>void</code> can also "return" an error. Since we don't use exceptions (see <a href="#exceptions">Exceptions</a>) we capture this pattern using <code><a class="el" href="classTry.html">Try</a>&lt;<a class="el" href="structNothing.html">Nothing</a>&gt;</code> (see <a href="#try">Try</a>).</p>
<p><a href="fs"></a></p>
<h2><code>fs::</code></h2>
<p>A collection of utilities for working with a filesystem. Currently we provide <code><a class="el" href="namespacefs.html#a60a9e5ca4119866d80691ce3c4701dc9">fs::size</a></code>, <code><a class="el" href="namespacefs.html#ab5ede09379c4793ba4477c7e4573670a">fs::usage</a></code>, and <code><a class="el" href="namespacefs.html#a68279f7514744bb2af74dfce8bb0bbc7">fs::symlink</a></code>.</p>
<p><a href="gzip"></a></p>
<h2><code>gzip::</code></h2>
<p>A collection of utilities for doing gzip compression and decompression using <code><a class="el" href="namespacegzip.html#a3d8dfe96cea393d74c2d050ca8c62615">gzip::compress</a></code> and <code><a class="el" href="namespacegzip.html#ac92b37d9b89d82f553384a4d69799d4f">gzip::decompress</a></code>.</p>
<div class="fragment"><div class="line"><a class="code" href="namespacegzip.html#ac92b37d9b89d82f553384a4d69799d4f">gzip::decompress</a>(<a class="code" href="namespacegzip.html#a3d8dfe96cea393d74c2d050ca8c62615">gzip::compress</a>(<span class="stringliteral">&quot;hello world&quot;</span>));</div></div><!-- fragment --><p><a href="json"></a></p>
<h2><code><a class="el" href="namespaceJSON.html">JSON</a>::</code></h2>
<p><em>Requires Boost.</em></p>
<p>Provides structures and rendering of the JavaScript Object Notation (<a class="el" href="namespaceJSON.html">JSON</a>) grammar using <code>boost::variant</code>. A <a class="el" href="namespaceJSON.html">JSON</a> "value" (<code><a class="el" href="structJSON_1_1Value.html">JSON::Value</a></code>) is one of (i.e., a variant of) <code><a class="el" href="structJSON_1_1String.html">JSON::String</a></code>, <code><a class="el" href="structJSON_1_1Number.html">JSON::Number</a></code>, <code><a class="el" href="structJSON_1_1Object.html">JSON::Object</a></code>, <code><a class="el" href="structJSON_1_1Array.html">JSON::Array</a></code>, <code><a class="el" href="structJSON_1_1True.html">JSON::True</a></code>, <code><a class="el" href="structJSON_1_1False.html">JSON::False</a></code>, and <code><a class="el" href="structJSON_1_1Null.html">JSON::Null</a></code>.</p>
<p>We explicitly define 'true' (<code><a class="el" href="structJSON_1_1True.html">JSON::True</a></code>), 'false' (<code><a class="el" href="structJSON_1_1False.html">JSON::False</a></code>), and 'null' (<code><a class="el" href="structJSON_1_1Null.html">JSON::Null</a></code>), for clarity and also because <code>boost::variant</code> "picks" the wrong type when we try and use <code>std::string</code>, <code>long</code> (or <code>int</code>), <code>double</code> (or <code>float</code>), and <code>bool</code> all in the same variant.</p>
<p>We could have avoided using <code><a class="el" href="structJSON_1_1String.html">JSON::String</a></code> or <code><a class="el" href="structJSON_1_1Number.html">JSON::Number</a></code> and just used <code>std::string</code> and <code>double</code> respectively, but we choose to include them for completeness (although, this does slow compilation due to the extra template instantiations). That being said, you can use the native types in place of constructing the <code><a class="el" href="namespaceJSON.html">JSON</a></code> wrapper. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// {</span></div><div class="line"><span class="comment">//   &quot;foo&quot;: &quot;value1&quot;,</span></div><div class="line"><span class="comment">//   &quot;bar&quot;: &quot;value2&quot;,</span></div><div class="line"><span class="comment">//   &quot;baz&quot;: 42.0,</span></div><div class="line"><span class="comment">//   &quot;bam&quot;: 0.42,</span></div><div class="line"><span class="comment">// }</span></div><div class="line"><a class="code" href="structJSON_1_1Object.html">JSON::Object</a> object;</div><div class="line"><span class="keywordtype">object</span>.<a class="code" href="structJSON_1_1Object.html#a41bbf967d564eb3f57c2bb5453a0e7af">values</a>[<span class="stringliteral">&quot;foo&quot;</span>] = <a class="code" href="structJSON_1_1String.html">JSON::String</a>(<span class="stringliteral">&quot;value1&quot;</span>);</div><div class="line"><span class="keywordtype">object</span>.values[<span class="stringliteral">&quot;bar&quot;</span>] = <span class="stringliteral">&quot;value2&quot;</span>;</div><div class="line"><span class="keywordtype">object</span>.values[<span class="stringliteral">&quot;baz&quot;</span>] = <a class="code" href="structJSON_1_1Number.html">JSON::Number</a>(42.0);</div><div class="line"><span class="keywordtype">object</span>.values[<span class="stringliteral">&quot;bam&quot;</span>] = 0.42;</div></div><!-- fragment --><p>Of course, nesting of a <code><a class="el" href="structJSON_1_1Value.html">JSON::Value</a></code> is also permitted as per the <a class="el" href="namespaceJSON.html">JSON</a> specification:</p>
<div class="fragment"><div class="line"><span class="comment">// An array of objects:</span></div><div class="line"><span class="comment">// [</span></div><div class="line"><span class="comment">//   { &quot;first&quot;: &quot;Benjamin&quot;, &quot;last&quot;: &quot;Hindman&quot; },</span></div><div class="line"><span class="comment">//   { &quot;first&quot;: &quot;Michael&quot;, &quot;last&quot;: &quot;Hindman&quot; }</span></div><div class="line"><span class="comment">// ]</span></div><div class="line"><a class="code" href="structJSON_1_1Array.html">JSON::Array</a> array;</div><div class="line"></div><div class="line"><a class="code" href="structJSON_1_1Object.html">JSON::Object</a> object1;</div><div class="line">object1.<a class="code" href="structJSON_1_1Object.html#a41bbf967d564eb3f57c2bb5453a0e7af">values</a>[<span class="stringliteral">&quot;first&quot;</span>] = <span class="stringliteral">&quot;Benjamin&quot;</span>;</div><div class="line">object1.<a class="code" href="structJSON_1_1Object.html#a41bbf967d564eb3f57c2bb5453a0e7af">values</a>[<span class="stringliteral">&quot;last&quot;</span>] = <span class="stringliteral">&quot;Hindman&quot;</span>;</div><div class="line"></div><div class="line">array.<a class="code" href="structJSON_1_1Array.html#aed41033b7cd6a2c2e7dcc6f0c48a4563">values</a>.push_back(object1);</div><div class="line"></div><div class="line"><a class="code" href="structJSON_1_1Object.html">JSON::Object</a> object2;</div><div class="line">object2.<a class="code" href="structJSON_1_1Object.html#a41bbf967d564eb3f57c2bb5453a0e7af">values</a>[<span class="stringliteral">&quot;first&quot;</span>] = <span class="stringliteral">&quot;Michael&quot;</span>;</div><div class="line">object2.<a class="code" href="structJSON_1_1Object.html#a41bbf967d564eb3f57c2bb5453a0e7af">values</a>[<span class="stringliteral">&quot;last&quot;</span>] = <span class="stringliteral">&quot;Hindman&quot;</span>;</div><div class="line"></div><div class="line">array.<a class="code" href="structJSON_1_1Array.html#aed41033b7cd6a2c2e7dcc6f0c48a4563">values</a>.push_back(object2);</div></div><!-- fragment --><p>You can "render" a <a class="el" href="namespaceJSON.html">JSON</a> value using <code>std::ostream operator&lt;&lt;</code> (or by using <code>stringify</code> (see <a href="#stringify">here</a>).</p>
<p><a href="jsonify"></a></p>
<h2><code>jsonify</code></h2>
<p><code>jsonify</code> takes an instance of a C++ object and returns a representation of <code><a class="el" href="namespaceJSON.html">JSON</a></code> string captured in a light-weight proxy object. The proxy object can either be implicitly converted to a <code>std::string</code>, or directly inserted into an output stream.</p>
<p><code><a class="el" href="jsonify_8hpp.html#ab2d3ecf67ed06919e96e5e97b2effdc3">jsonify(const T&amp;)</a></code> is implemented by calling the function <code>json</code>. We perform unqualified function call so that it can detect overloads via argument dependent lookup. That is, we will search for, and use a free function named <code>json</code> in the same namespace as <code>T</code>.</p>
<blockquote class="doxtable">
<p>NOTE: This relationship is similar to <code>boost::hash</code> and <code>hash_value</code>. </p>
</blockquote>
<p><code>json</code> takes two parameters: a pointer to a writer type, and the type of the object. The following are the available writers and their member functions:</p>
<ul>
<li><code>BooleanWriter</code> &ndash; <code>set(value)</code></li>
<li><code>NumberWriter</code> &ndash; <code>set(value)</code></li>
<li><code>StringWriter</code> &ndash; <code>append(value)</code></li>
<li><code>ArrayWriter</code> &ndash; <code>element(value)</code></li>
<li><code>ObjectWriter</code> &ndash; <code>field(key, value)</code></li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>store {</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Customer</div><div class="line">{</div><div class="line">  std::string first_name;</div><div class="line">  std::string last_name;</div><div class="line">  <span class="keywordtype">int</span> age;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespacemesos_1_1internal.html#a3752d85ef726065c6c1b946eef1ba87a">json</a>(<a class="code" href="classJSON_1_1ObjectWriter.html">JSON::ObjectWriter</a>* writer, <span class="keyword">const</span> Customer&amp; customer)</div><div class="line">{</div><div class="line">  writer-&gt;<a class="code" href="classJSON_1_1ObjectWriter.html#a6d51b20c4c2410b540433d5dd1720703">field</a>(<span class="stringliteral">&quot;first name&quot;</span>, customer.first_name);</div><div class="line">  writer-&gt;<a class="code" href="classJSON_1_1ObjectWriter.html#a6d51b20c4c2410b540433d5dd1720703">field</a>(<span class="stringliteral">&quot;last name&quot;</span>, customer.last_name);</div><div class="line">  writer-&gt;<a class="code" href="classJSON_1_1ObjectWriter.html#a6d51b20c4c2410b540433d5dd1720703">field</a>(<span class="stringliteral">&quot;age&quot;</span>, customer.age);</div><div class="line">}</div><div class="line"></div><div class="line">} <span class="comment">// namespace store {</span></div><div class="line"></div><div class="line">store::Customer customer{<span class="stringliteral">&quot;michael&quot;</span>, <span class="stringliteral">&quot;park&quot;</span>, 25};</div><div class="line">std::cout &lt;&lt; <a class="code" href="jsonify_8hpp.html#ab2d3ecf67ed06919e96e5e97b2effdc3">jsonify</a>(customer);</div><div class="line"><span class="comment">// prints: {&quot;first name&quot;:&quot;michael&quot;,&quot;last name&quot;:&quot;park&quot;,&quot;age&quot;:25}</span></div></div><!-- fragment --><p><code>jsonify(const F&amp;)</code> overload takes a function object <code>F</code> that takes a pointer to writer. This is useful in cases where we don't want to define a public <code>json</code> function out-ouf-line.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>store {</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Customer</div><div class="line">{</div><div class="line">  std::string first_name;</div><div class="line">  std::string last_name;</div><div class="line">  <span class="keywordtype">int</span> age;</div><div class="line">};</div><div class="line"></div><div class="line">} <span class="comment">// namespace store {</span></div><div class="line"></div><div class="line">store::Customer customer{<span class="stringliteral">&quot;michael&quot;</span>, <span class="stringliteral">&quot;park&quot;</span>, 25};</div><div class="line">std::cout &lt;&lt; <a class="code" href="jsonify_8hpp.html#ab2d3ecf67ed06919e96e5e97b2effdc3">jsonify</a>([&amp;customer](<a class="code" href="classJSON_1_1ObjectWriter.html">JSON::ObjectWriter</a>* writer) {</div><div class="line">  writer-&gt;<a class="code" href="classJSON_1_1ObjectWriter.html#a6d51b20c4c2410b540433d5dd1720703">field</a>(<span class="stringliteral">&quot;first name&quot;</span>, customer.first_name);</div><div class="line">  writer-&gt;<a class="code" href="classJSON_1_1ObjectWriter.html#a6d51b20c4c2410b540433d5dd1720703">field</a>(<span class="stringliteral">&quot;last name&quot;</span>, customer.last_name);</div><div class="line">  writer-&gt;<a class="code" href="classJSON_1_1ObjectWriter.html#a6d51b20c4c2410b540433d5dd1720703">field</a>(<span class="stringliteral">&quot;age&quot;</span>, customer.age);</div><div class="line">});</div><div class="line"><span class="comment">// prints: {&quot;first name&quot;:&quot;michael&quot;,&quot;last name&quot;:&quot;park&quot;,&quot;age&quot;:25}</span></div></div><!-- fragment --><p><a href="lambda"></a></p>
<h2><code>lambda::</code></h2>
<p>To help deal with compatibility issues between C++98/03 and C++11 we wrap some of the TR1 types from <code>functional</code> in <code>lambda</code>. That way, when using <code>lambda::bind</code> you'll get <code>std::tr1::bind</code> where TR1 is available and <code>std::bind</code> when C++11 is available.</p>
<p><a href="net"></a></p>
<h2><code>net::</code></h2>
<p>A collection of utilities for working with the networking subsystem. Currently we provide <code><a class="el" href="namespacenet.html#acc396217b0098a9fcfdce55d76fc548d">net::download</a></code> and <code><a class="el" href="namespacenet.html#a0236310e7c9452a2030371c7793bd0d0">net::getHostname</a></code>.</p>
<p><a href="os"></a></p>
<h2><code>os::</code></h2>
<p>The <code>os</code> namespace provides numerous utilities for working with the operating system. Most of these utilities are simple wrappers around C-style functions that don't cleanly take or return C++ types, for example <code><a class="el" href="namespaceos.html#a41d44010fdf2e321ff954b0cc94aef06">os::getenv</a></code>, <code><a class="el" href="namespaceos.html#ac0f608e2a32764327e38c53d0d51527d">os::setenv</a></code>, <code><a class="el" href="namespaceos.html#a7fd21154b15bc00e31e2b457cab83ff2">os::realpath</a></code>, etc. The library also includes a handful of "shell familiars", such as <code><a class="el" href="namespaceos.html#a655811780af327b5a925db5ad3a0b8d7">os::chown</a></code>, <code><a class="el" href="namespaceos.html#a63be913dceea50b05a9c0ab845bd43c2">os::touch</a></code>, <code><a class="el" href="namespaceos.html#ae1a95c76dff4f12df27a580865904f46">os::ls</a></code>, <code><a class="el" href="namespaceos.html#a965c9c19022c17c26fc5720f718e6c1a">os::find</a></code>, <code><a class="el" href="namespaceos.html#ac6849a50cb5add0e10fcdfc2e38dadd1">os::su</a></code>, <code><a class="el" href="namespaceos.html#acaf701ed1dd05d56cc36c5ff034ff5bd">os::glob</a></code>, etc. We call out a few of the special abstractions below.</p>
<h4>Reading and Writing <code>std::string</code></h4>
<p>To make reading and writing from files easier there are implementations of <code><a class="el" href="namespaceos.html#a55f1b63e17f10cbbefdcd604805acf8a">os::read</a></code> and <code><a class="el" href="namespaceos.html#aec24e3d41a362b998b1c1d1044a60bf0" title="Performs a series of asynchronous writes, until all of data has been written. ">os::write</a></code> that take and return <code>std::string</code>.</p>
<h4>Files</h4>
<p>Most of the ways to get or set information about files requires complicated calls using the <code>stat</code> family of functions. We provide simple wrappers around <code>stat</code> via things like <code><a class="el" href="namespaceos.html#a69b3969276ffa4cb698b9431ee43bd7c">os::exists</a></code>, <code><a class="el" href="namespaceos_1_1stat.html#a37d4d39a889b955ca3c40c9bd923afe0">os::stat::isdir</a></code>, <code><a class="el" href="namespaceos_1_1stat.html#a3e080b3a2e48ab63dabb184e8fb6f5e4">os::stat::isfile</a></code>, and <code><a class="el" href="namespaceos_1_1stat.html#a0ba4d272b938da76e404648103077480">os::stat::islink</a></code>.</p>
<h4>Processes</h4>
<p>There are some fairly extensive abstractions around getting process information from the operating system. There is an <code><a class="el" href="structos_1_1Process.html">os::Process</a></code> type that gets provided by utiltiies like <code><a class="el" href="namespaceos.html#aa98ca8ac255e2b9c689979a1b40084d3">os::processes</a></code>. You can construct an arbitrary fork/exec process tree by constructing an <code><a class="el" href="structos_1_1Fork.html">os::Fork</a></code>, get all the processes in a process tree using <code><a class="el" href="namespaceos.html#a735da8cc66bb949314838d8569db519e">os::pstree</a></code>, and kill all the processes in a process tree using <code><a class="el" href="namespaceos.html#ae7bf571af786eae39cb025d516566168">os::killtree</a></code> (the latter is similar to the shell command <code>kill</code> but strictly more powerful in that it can walk a process tree, following groups and sessions if requested).</p>
<h4><code>sysctl</code></h4>
<p>There is an <code><a class="el" href="structos_1_1sysctl.html">os::sysctl</a></code> abstraction for getting and setting kernel state on OS X.</p>
<h4>Signals</h4>
<p>There are a handful of wrappers that make working with signals easier, including <code><a class="el" href="namespaceos_1_1signals.html#a712c95e437c6ae6caa6fbc6dcce30f26">os::signals::pending</a></code>, <code><a class="el" href="namespaceos_1_1signals.html#af714cced9d9eb5640c62ad2dca1cb24a">os::signals::block</a></code>, and <code><a class="el" href="namespaceos_1_1signals.html#af3a85f6669d18ed19b920de56006e372">os::signals::unblock</a></code>. In addition, there is a suppression abstraction that enables executing a block of code while blocking a signal. Consider writing to a pipe which may raise a SIGPIPE if the pipe has been closed. Using <code>suppress</code> you can do:</p>
<div class="fragment"><div class="line">suppress (SIGPIPE) {</div><div class="line">  <a class="code" href="windows_8hpp.html#ab3965335d57fae19965cb8248954d610">write</a>(fd, data, <a class="code" href="namespaceos_1_1stat.html#aac17a91dd3f91341b8c4021025e89b04">size</a>);</div><div class="line">  <span class="keywordflow">if</span> (errno == EPIPE) {</div><div class="line">    <span class="comment">// The pipe has been closed!</span></div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a href="path"></a></p>
<h2><code>path::</code></h2>
<p>The <code>path</code> namespace provides the <code><a class="el" href="namespacepath.html#a9118000b312aa9e21dcaa38b524ed012">path::join</a></code> function for joining toghether filesystem paths. Additionally to the <code>path</code> namespace there also exists the class <code><a class="el" href="classPath.html" title="Represents a POSIX file systems path and offers common path manipulations. ">Path</a></code>. <code><a class="el" href="classPath.html" title="Represents a POSIX file systems path and offers common path manipulations. ">Path</a></code> provides <code>basename()</code> and <code>dirname()</code> as thread safe replacements for standard <code>::basename()</code> and <code>::dirname()</code>.</p>
<p><a href="proc"></a></p>
<h2><code>proc::</code></h2>
<p><em>Requires Linux.</em></p>
<p>The <code>proc</code> namespace provides some abstractions for working with the Linux <code>proc</code> filesystem. The key abstractions are <code><a class="el" href="structproc_1_1ProcessStatus.html">proc::ProcessStatus</a></code> which models the data provided in <code>/proc/[pid]/stat</code> and <code><a class="el" href="structproc_1_1SystemStatus.html">proc::SystemStatus</a></code> which models the data provided in <code>/proc/stat</code>.</p>
<p><a href="protobuf"></a></p>
<h2><code>protobuf::</code></h2>
<p><em>Requires protobuf.</em></p>
<p>Helpers for reading and writing protobufs from files and file descriptors are provided via <code><a class="el" href="namespaceprotobuf.html#a8aff49186d1e5005b033c5cb9a1dc35e">protobuf::read</a></code> and <code><a class="el" href="namespaceprotobuf.html#acb3c1e5a20db96a5aa8b2876cfa7e0e5">protobuf::write</a></code>. These assume a "recordio" format where the length of the serialized data is read/written first followed by the actual data.</p>
<p>There is also a protobuf to <a class="el" href="namespaceJSON.html">JSON</a> converter via <code><a class="el" href="namespaceJSON.html#a93c179a1a5bd4164169d47cb1803f2a6">JSON::protobuf</a></code> that enables serializing a protobuf into <a class="el" href="namespaceJSON.html">JSON</a>:</p>
<div class="fragment"><div class="line">google::protobuf::Message message;</div><div class="line">... <a class="code" href="namespacemesos_1_1internal_1_1log.html#a48c2c5d611b29b4237b34b35b4583963">fill</a> in message ...</div><div class="line">JSON::Object o = <a class="code" href="namespaceJSON.html#a93c179a1a5bd4164169d47cb1803f2a6">JSON::protobuf</a>(message);</div></div><!-- fragment --><p><a href="strings"></a></p>
<h2><code>strings::</code></h2>
<p>Utilities for inspecting and manipulating strings are available in the <code>strings</code> namespace. This includes varying tokenization techniques via <code><a class="el" href="namespacestrings.html#ad0ddfb890f23f1c82a5a2fe9c8cc507a">strings::tokenize</a></code>, <code><a class="el" href="namespacestrings.html#af29d42496fa180541f4f95e2370120f4">strings::split</a></code>, and <code><a class="el" href="namespacestrings.html#adaaf307e99ca9a9e434c43d7fda7d298">strings::pairs</a></code>.</p>
<p>String formatting is provided via <code><a class="el" href="namespacestrings.html#a7884a23bea2a6543b8a93ad48faabe0c">strings::format</a></code>. The <code><a class="el" href="namespacestrings.html#a7884a23bea2a6543b8a93ad48faabe0c">strings::format</a></code> functions produces strings based on the <code>printf</code> family of functions. Except, unlike the <code>printf</code> family of functions, the <code><a class="el" href="namespacestrings.html#a7884a23bea2a6543b8a93ad48faabe0c">strings::format</a></code> routines attempt to "stringify" (see <a href="#stringify">here</a>) any arguments that are not POD types (i.e., "plain old data": primitives, pointers, certain structs/classes and unions, etc). This enables passing structs/classes to <code><a class="el" href="namespacestrings.html#a7884a23bea2a6543b8a93ad48faabe0c">strings::format</a></code> provided there is a definition/specialization of <code>std::ostream operator&lt;&lt;</code> available for that type. Note that the <code>s</code> format specifier is expected for each argument that gets passed. A specialization for <code>std::string</code> is also provided so that <code>std::string::c_str</code> is not necessary (but again, <code>s</code> is expected as the format specifier).</p>
<p><a href="flags"></a></p>
<h2>Command Line Flags</h2>
<p>One frustration with existing command line flags libraries was the burden they put on writing tests that attempted to have many different instantiations of the flags. For example, running two instances of the same component within a test where each instance was started with different command line flags. To solve this, we provide a command line flags abstraction called <code>Flags</code> (in the <code>flags</code> namespace) that you can extend to define your own flags:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyFlags : <a class="code" href="classflags_1_1Flags.html">flags::Flags</a></div><div class="line">{</div><div class="line">  MyFlags()</div><div class="line">  {</div><div class="line">    <span class="comment">// A flag with a default value.</span></div><div class="line">    <a class="code" href="namespaceprocess_1_1metrics.html#a15af50f3f4dbcca2f7c619ccfbaa70b2">add</a>(&amp;MyFlags::foo,</div><div class="line">        <span class="stringliteral">&quot;foo&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;Some information about foo&quot;</span>,</div><div class="line">        DEFAULT_VALUE_FOR_FOO);</div><div class="line"></div><div class="line">    <span class="comment">// A flag with out a default value,</span></div><div class="line">    <span class="comment">// defined below with an `Option`.</span></div><div class="line">    <a class="code" href="namespaceprocess_1_1metrics.html#a15af50f3f4dbcca2f7c619ccfbaa70b2">add</a>(&amp;MyFlags::bar,</div><div class="line">        <span class="stringliteral">&quot;bar&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;Some information about bar&quot;</span>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> foo;</div><div class="line">  <a class="code" href="classOption.html">Option&lt;std::string&gt;</a> bar;</div><div class="line">};</div></div><!-- fragment --><p>You can then load the flags via <code>argc</code> and <code>argv</code> via:</p>
<div class="fragment"><div class="line">MyFlags <a class="code" href="namespacemesos_1_1internal_1_1tests.html#af8289f648a916c3f66923867452c7b1b">flags</a>;</div><div class="line"><a class="code" href="classTry.html">Try&lt;Nothing&gt;</a> load = flags.load(<a class="code" href="structNone.html">None</a>(), argc, argv);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (load.<a class="code" href="classTry.html#a2e52c7006437d2cf421b373f75e3c767">isError</a>()) { ... }</div><div class="line"></div><div class="line">... flags.foo ...</div><div class="line">... flags.bar.isSome() ... flags.bar.get() ...</div></div><!-- fragment --><p>You can load flags from the environment in addition to <code>argc</code> and <code>argv</code> by specifying a prefix to use when looking for flags:</p>
<div class="fragment"><div class="line">MyFlags <a class="code" href="namespacemesos_1_1internal_1_1tests.html#af8289f648a916c3f66923867452c7b1b">flags</a>;</div><div class="line"><a class="code" href="classTry.html">Try&lt;Nothing&gt;</a> load = flags.load(<span class="stringliteral">&quot;PREFIX_&quot;</span>, argc, argv);</div></div><!-- fragment --><p>Then both PREFIX_foo and PREFIX_bar will be loaded from the environemnt as well as possibly from on the command line.</p>
<p>There are various ways to deal with unknown flags (i.e., <code>--baz</code> in our example above) and duplicates (i.e., <code>--foo</code> on the command line twice or once in the environment and once on the command line). See the header files for the various <code>load</code> overloads.</p>
<p><a href="collections"></a></p>
<h2>Collections</h2>
<p>Many of the collections and containers provided either by Boost or the C++ standard are cumbersome to use or yield brittle, hard to maintain code. For many of the standard data structures we provide wrappers with modified interfaces often simplified or enhanced using types like <code><a class="el" href="classTry.html">Try</a></code> and <code><a class="el" href="classOption.html">Option</a></code>.</p>
<blockquote class="doxtable">
<p>NOTE: The collections are not namespaced. </p>
</blockquote>
<p>Some of these wrappers use the Boost implementations of these data structures, including: <code>hashmap</code>, <code>hashset</code>, <code>linkedhashmap</code>, <code>multihashmap</code>, <code>multimap</code>.</p>
<p>There is a <code><a class="el" href="classSet.html">Set</a></code> abstraction for working with a <code>std::set</code> as well as some overloaded operators for doing set union (<code>|</code>), set intersection (<code>&amp;</code>), and set appending (<code>+</code>).</p>
<p>Finally, there is a <code>cache</code> implementation (also requires Boost) that provides a templated implementation of a least-recently used (LRU) cache. Note that the key type must be compatible with <code>boost::unordered_map</code>.</p>
<p><a href="miscellaneous"></a></p>
<h2>Miscellaneous</h2>
<p>There are a handful of types and utilties that fall into the miscellaneous category. Note that like the collections <em>these are not namespaced</em>.</p>
<h4><code><a class="el" href="classBytes.html">Bytes</a></code></h4>
<p>Used to represent some magnitude of bytes, i.e., kilobytes, megabytes, gigabytes, etc. The main way to construct a <code><a class="el" href="classBytes.html">Bytes</a></code> is to invoke <code><a class="el" href="classBytes.html#a7cfe284176d1712aea563e5ddb590b30">Bytes::parse</a></code> which expects a string made up of a number and a unit, i.e., <code>42B</code>, <code>42MB</code>, <code>42GB</code>, <code>42TB</code>. For each of the supported units there are associated types: <code><a class="el" href="classMegabytes.html">Megabytes</a></code>, <code><a class="el" href="classGigabytes.html">Gigabytes</a></code>, <code><a class="el" href="classTerabytes.html">Terabytes</a></code>. Each of these types inherit from <code><a class="el" href="classBytes.html">Bytes</a></code> and can be used anywhere a <code><a class="el" href="classBytes.html">Bytes</a></code> is expected, for example:</p>
<div class="fragment"><div class="line"><a class="code" href="classTry.html">Try&lt;Bytes&gt;</a> bytes = <a class="code" href="classBytes.html#a7cfe284176d1712aea563e5ddb590b30">Bytes::parse</a>(<span class="stringliteral">&quot;32MB&quot;</span>);</div><div class="line"></div><div class="line"><a class="code" href="classBytes.html">Bytes</a> bytes = <a class="code" href="classMegabytes.html">Megabytes</a>(10);</div></div><!-- fragment --><p>There are operators for comparing (equal to, greater than or less than, etc) and manipulating (addition, subtraction, etc) <code><a class="el" href="classBytes.html">Bytes</a></code> objects, as well as a <code>std::ostream operator&lt;&lt;</code> overload (thus making them stringifiable, see <a href="#stringify">here</a>). For example:</p>
<div class="fragment"><div class="line"><a class="code" href="classTry.html">Try&lt;Bytes&gt;</a> bytes = <a class="code" href="classBytes.html#a7cfe284176d1712aea563e5ddb590b30">Bytes::parse</a>(<span class="stringliteral">&quot;32MB&quot;</span>);</div><div class="line"></div><div class="line"><a class="code" href="classBytes.html">Bytes</a> tengb = <a class="code" href="classGigabytes.html">Gigabytes</a>(10);</div><div class="line"><a class="code" href="classBytes.html">Bytes</a> onegb = <a class="code" href="classMegabytes.html">Megabytes</a>(1024);</div><div class="line"></div><div class="line"><a class="code" href="namespacens.html#a28116b46e6543597a11733424cd1aa20">stringify</a>(tengb + onegb); <span class="comment">// Yields &quot;11GB&quot;.</span></div></div><!-- fragment --><h4><code><a class="el" href="classDuration.html">Duration</a></code></h4>
<p>Used to represent some duration of time. The main way to construct a <code><a class="el" href="classDuration.html">Duration</a></code> is to invoke <code><a class="el" href="classDuration.html#aef0d672430019fd5ded022bba35717b8">Duration::parse</a></code> which expects a string made up of a number and a unit, i.e., <code>42ns</code>, <code>42us</code>, <code>42ms</code>, <code>42secs</code>, <code>42mins</code>, <code>42hrs</code>, <code>42days</code>, <code>42weeks</code>. For each of the supported units there are associated types: <code><a class="el" href="classNanoseconds.html">Nanoseconds</a></code>, <code><a class="el" href="classMicroseconds.html">Microseconds</a></code>, <code><a class="el" href="classMilliseconds.html">Milliseconds</a></code>, <code><a class="el" href="classSeconds.html">Seconds</a></code>, <code><a class="el" href="classMinutes.html">Minutes</a></code>, <code><a class="el" href="classHours.html">Hours</a></code>, <code><a class="el" href="classDays.html">Days</a></code>, <code><a class="el" href="classWeeks.html">Weeks</a></code>. Each of these types inherit from <code><a class="el" href="classDuration.html">Duration</a></code> and can be used anywhere a <code><a class="el" href="classDuration.html">Duration</a></code> is expected, for example:</p>
<div class="fragment"><div class="line"><a class="code" href="classDuration.html">Duration</a> d = <a class="code" href="classSeconds.html">Seconds</a>(5);</div></div><!-- fragment --><p>There are operators for comparing (equal to, greater than or less than, etc) and manipulating (addition, subtraction, etc) <code><a class="el" href="classDuration.html">Duration</a></code> objects, as well as a <code>std::ostream operator&lt;&lt;</code> overload (thus making them stringifiable, see <a href="#stringify">here</a>). Note that the <code>std::ostream operator&lt;&lt;</code> overload formats the output (including the unit) based on the magnitude, for example:</p>
<div class="fragment"><div class="line"><a class="code" href="namespacens.html#a28116b46e6543597a11733424cd1aa20">stringify</a>(<a class="code" href="classSeconds.html">Seconds</a>(42)); <span class="comment">// Yields &quot;42secs&quot;.</span></div><div class="line"><a class="code" href="namespacens.html#a28116b46e6543597a11733424cd1aa20">stringify</a>(<a class="code" href="classSeconds.html">Seconds</a>(120)); <span class="comment">// Yields &quot;2mins&quot;.</span></div></div><!-- fragment --><h4><code><a class="el" href="classStopwatch.html">Stopwatch</a></code></h4>
<p>A data structure for recording elapsed time (according to the underlying operating system clock):</p>
<div class="fragment"><div class="line"><a class="code" href="classStopwatch.html">Stopwatch</a> stopwatch;</div><div class="line">stopwatch.<a class="code" href="classStopwatch.html#a6d01ecc80c92f1d5210cd9c3eb72883d">start</a>();</div><div class="line"></div><div class="line"><a class="code" href="classDuration.html">Duration</a> elapsed = stopwatch.<a class="code" href="classStopwatch.html#a2faf79fced7d3459a654114fabb2bf7b">elapsed</a>();</div><div class="line"></div><div class="line">stopwatch.<a class="code" href="classStopwatch.html#aa0266311b7392b948061bb985b49cff4">stop</a>();</div><div class="line"></div><div class="line">assert(elapsed &lt;= stopwatch.<a class="code" href="classStopwatch.html#a2faf79fced7d3459a654114fabb2bf7b">elapsed</a>());</div></div><!-- fragment --><h4><code>UUID</code></h4>
<p><em>Requires Boost.</em></p>
<p>A wrapper around <code>boost::uuid</code> with a simpler interface.</p>
<h4><code>EXIT</code></h4>
<p>A macro for exiting an application without generating a signal (such as from <code>assert</code>) or a stack trace (such as from Google logging's <code>CHECK</code> family of macros). This is useful if you want to exit the program with an error message:</p>
<div class="fragment"><div class="line"><a class="code" href="exit_8hpp.html#a536432347f1ad965e8116c2940fbf110">EXIT</a>(42) &lt;&lt; <span class="stringliteral">&quot;You&#39;ve provided us bad input ...&quot;</span>;</div></div><!-- fragment --><p>Note that a newline is automatically appended and the processes exit status is set to 42.</p>
<h4><code>foreach</code></h4>
<p><em>Requires Boost.</em></p>
<p>Macros for looping over collections:</p>
<div class="fragment"><div class="line">std::list&lt;std::string&gt; l;</div><div class="line"></div><div class="line"><span class="keywordflow">foreach</span> (std::string s, l) {}</div><div class="line"><span class="keywordflow">foreach</span> (<span class="keyword">const</span> std::string&amp; s, l) {}</div><div class="line"></div><div class="line">std::map&lt;std::string, int&gt; m;</div><div class="line"></div><div class="line"><a class="code" href="foreach_8hpp.html#a30b2e89f0b0754c8cd9554fca6321816">foreachpair</a> (std::string s, <span class="keywordtype">int</span> i, m) {}</div><div class="line"><a class="code" href="foreach_8hpp.html#a30b2e89f0b0754c8cd9554fca6321816">foreachpair</a> (<span class="keyword">const</span> std::string&amp; s, <span class="keywordtype">int</span> i, m) {}</div><div class="line"></div><div class="line"><a class="code" href="foreach_8hpp.html#a8779422fd95c46547b4e68b43b5100af">foreachkey</a> (<span class="keyword">const</span> std::string&amp; s, m) {}</div><div class="line"><a class="code" href="foreach_8hpp.html#a7a3e7f04575d773844d34e493d23da8d">foreachvalue</a> (<span class="keywordtype">int</span> i, m) {}</div></div><!-- fragment --><h4><code>numify</code></h4>
<p><em>Requires Boost.</em></p>
<p>Wraps <code>boost::lexical_cast</code> for converting strings to numbers but returns a <code><a class="el" href="classTry.html">Try</a></code> rather than throwing exceptions.</p>
<p><a href="stringify"></a></p>
<h4><code>stringify</code></h4>
<p>Converts arbitrary types into strings by attempting to use an overloaded <code>std::ostream operator&lt;&lt;</code> (otherwise compilation fails). Note that <code>stringify</code> aborts the program if the stringification process fails.</p>
<h4><code>ThreadLocal</code></h4>
<p><em>Requires pthreads.</em></p>
<p>You can give every thread it's own copy of some data using the <code>ThreadLocal</code> abstraction:</p>
<div class="fragment"><div class="line">ThreadLocal&lt;std::string&gt; local;</div><div class="line">local = <span class="keyword">new</span> std::string(<span class="stringliteral">&quot;hello&quot;</span>);</div><div class="line">local-&gt;append(<span class="stringliteral">&quot; world&quot;</span>);</div><div class="line">std::string* s = local;</div><div class="line">assert(*s == <span class="stringliteral">&quot;hello world&quot;</span>);</div></div><!-- fragment --><p><a href="testing"></a></p>
<h2>Testing</h2>
<p>There are some macros provided for integration with gtest that make the tests less verbose while providing better messages when tests do fail:</p>
<div class="fragment"><div class="line"><a class="code" href="classTry.html">Try&lt;int&gt;</a> t = foo();</div><div class="line"></div><div class="line"><span class="comment">// Rather than:</span></div><div class="line">ASSERT(t.<a class="code" href="classTry.html#af445dc5001bc01cfc86a8df5df79a29b">isSome</a>()) &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; t.<a class="code" href="classTry.html#a177038e5012bde890795ee82d3986380">error</a>();</div><div class="line"></div><div class="line"><span class="comment">// Just do:</span></div><div class="line"><a class="code" href="3rdparty_2stout_2include_2stout_2gtest_8hpp.html#ad6cfa825ea947ec3070622a5bd6fb9e0">ASSERT_SOME</a>(t);</div></div><!-- fragment --><p>There available macros include <code>ASSERT_SOME</code>, <code>EXPECT_SOME</code>, <code>ASSERT_NONE</code>, <code>EXPECT_NONE</code>, <code>ASSERT_ERROR</code>, <code>EXPECT_ERROR</code>, <code>ASSERT_SOME_EQ</code>, <code>EXPECT_SOME_EQ</code>, <code>ASSERT_SOME_TRUE</code>, <code>EXPECT_SOME_TRUE</code>, <code>ASSERT_SOME_FALSE</code>, <code>EXPECT_SOME_FALSE</code>.</p>
<p><a href="philosophy"></a></p>
<h2>Philosophy</h2>
<p>*"Premature optimization is the root of all evil."*</p>
<p>You'll notice that the library is designed in a way that can lead to a lot of copying. This decision was deliberate. Capturing the semantics of pointer ownership is hard to enforce programmatically unless you copy, and in many instances these copies can be elided by an optimizing compiler. We've choosen safety rather than premature optimizations.</p>
<p>Note, however, that we plan to liberally augment the library as we add C++11 support. In particular, we plan to use rvalue references and std::unique_ptr (although, likely wrapped as Owned) in order to explicitly express ownership semantics. Until then, it's unlikely that the performance overhead incurred via any extra copying is your bottleneck, and if it is we'd love to hear from you!</p>
<p><a href="exceptions"></a></p>
<h3>Exceptions</h3>
<p>The library WILL NEVER throw exceptions and will attempt to capture any exceptions thrown by underlying C++ functions and convert them into an <a href="#error">Error</a>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
