<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Apache Mesos: Libprocess Developer Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Mesos
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Libprocess Developer Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><em>Note</em> This Developer Guide is Work in Progress.</p>
<p>The library <em>libprocess</em> provides high level elements for an actor programming style with asynchronous message-handling and a variety of related basic system primitives. Its API and implementation are written in C++.</p>
<h2>Introduction</h2>
<p>The design of libprocess is inspired by <a href="http://erlang.org">Erlang</a>, a language that implements the <a href="http://en.wikipedia.org/wiki/Actor_model">actor model</a>.</p>
<p>As the name already suggests, one of the libprocess core concepts is a <a href="#process">Process</a>. This is a single threaded, independent actor which communicates with other processes, locally and remotely, by sending and receiving <a href="#http">HTTP requests and responses</a>.</p>
<p>At a higher level, functional composition of processes is facilitated using <a href="#futures-and-promises">futures and promises</a>.</p>
<h2>Overview</h2>
<h3>Table of Contents</h3>
<ul>
<li><a href="#processes">Processes and the Asynchronous Pimpl Pattern</a></li>
<li><a href="#futures-and-promises">Futures and Promises</a></li>
<li><a href="#http">HTTP</a></li>
<li><a href="#testing">Testing</a></li>
<li><a href="#miscellaneous-primitives">Miscellaneous Primitives</a> <hr/>
</li>
</ul>
<h2>Processes and the Asynchronous Pimpl Pattern</h2>
<p>A <code>process</code> is an actor, effectively a cross between a thread and an object.</p>
<p>Creating/spawning a process is very cheap (no actual thread gets created, and no thread stack gets allocated).</p>
<p>Each process has a queue of incoming events that it processes one at a time.</p>
<p>Processes provide execution contexts (only one thread executing within a process at a time so no need for per process synchronization).</p>
<h3><code>delay</code></h3>
<p><code>delay</code> instead of <a href="#dispatch">dispatching</a> for execution right away, it allows it to be scheduled after a certain time duration.</p>
<h3><code>dispatch</code></h3>
<p><code>dispatch</code> schedules a method for asynchronous execution.</p>
<h3><code>defer</code></h3>
<p>Objects like <code>Future</code> allow attaching callbacks that get executed <em>synchronously</em> on certain events, such as the completion of a future (e.g., <code>Future::then</code> and <code>Future::onReady</code>) or the failure of a future (e.g., <code>Future::onFailed</code>). It's usually desireable, however, to execute these callbacks <em>asynchronously</em>, and <code>defer</code> provides a mechanism to do so.</p>
<p><code>defer</code> is similar to <a href="#dispatch"><code>dispatch</code></a>, but rather than enqueing the execution of a method or function on the specified process immediately (i.e., synchronously), it returns a <code>Deferred</code>, which is a callable object that only after getting <em>invoked</em> will dispatch the method or function on the specified process. Said another way, using <code>defer</code> is a way to <em>defer</em> a <code>dispatch</code>.</p>
<p>As an example, consider the following function, which spawns a process and registers two callbacks on it, one using <code>defer</code> and another without it:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceprocess.html">process</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> foo()</div><div class="line">{</div><div class="line">  <a class="code" href="classprocess_1_1ProcessBase.html">ProcessBase</a> <a class="code" href="namespaceos.html#ae19e4161a51b86a1f330f3bf1dc75389">process</a>;</div><div class="line">  <a class="code" href="namespaceprocess.html#aff22904a83567125d3b4d0d88e5a2270">spawn</a>(process);</div><div class="line"></div><div class="line">  <a class="code" href="structprocess_1_1Deferred.html">Deferred&lt;void(int)&gt;</a> deferred = <a class="code" href="namespaceprocess.html#a8b27a2ef76eb133bf0ce7a5eea4fb77c">defer</a>(</div><div class="line">      process,</div><div class="line">      [](<span class="keywordtype">int</span> i) {</div><div class="line">        <span class="comment">// Invoked _asynchronously_ using `process` as the</span></div><div class="line">        <span class="comment">// execution context.</span></div><div class="line">      });</div><div class="line"></div><div class="line">  <a class="code" href="classprocess_1_1Promise.html">Promise&lt;int&gt;</a> <a class="code" href="namespacemesos_1_1internal_1_1log_1_1protocol.html#a3b1f8bd7b18c51af9d1f58842950b545">promise</a>;</div><div class="line"></div><div class="line">  promise.future().then(deferred);</div><div class="line"></div><div class="line">  promise.future().then([](<span class="keywordtype">int</span> i) {</div><div class="line">    <span class="comment">// Invoked synchronously from the execution context of</span></div><div class="line">    <span class="comment">// the thread that completes the future!</span></div><div class="line">  });</div><div class="line"></div><div class="line">  <span class="comment">// Executes both callbacks synchronously, which _dispatches_</span></div><div class="line">  <span class="comment">// the deferred lambda to run asynchronously in the execution</span></div><div class="line">  <span class="comment">// context of `process` but invokes the other lambda immediately.</span></div><div class="line">  promise.set(42);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceprocess.html#a20443908afa3212215166e26065349e5">terminate</a>(process);</div><div class="line">}</div></div><!-- fragment --><p>As another example, consider this excerpt from the Mesos project's <code>src/master/master.cpp</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// Start contending to be a leading master and detecting the current leader.</span></div><div class="line"><span class="comment">// NOTE: `.onAny` passes the relevant future to its callback as a parameter, and</span></div><div class="line"><span class="comment">// `lambda::_1` facilitates this when using `defer`.</span></div><div class="line">contender-&gt;contend()</div><div class="line">  .onAny(<a class="code" href="namespaceprocess.html#a8b27a2ef76eb133bf0ce7a5eea4fb77c">defer</a>(<span class="keyword">self</span>(), &amp;Master::contended, lambda::_1));</div></div><!-- fragment --><p>Why use <code>defer</code> in this context rather than just executing <code>Master::detected</code> synchronously? To answer this, we need to remember that when the promise associated with the future returned from <code>contender-&gt;contend()</code> is completed that will synchronously invoke all registered callbacks (i.e., the <code>Future::onAny</code> one in the example above), <em>which may be in a different process</em>! Without using <code>defer</code> the process responsible for executing <code>contender-&gt;contend()</code> will potentially cause <code>&amp;Master::contended</code> to get executed simultaneously (i.e., on a different thread) than the <code>Master</code> process! This creates the potential for a data race in which two threads access members of <code>Master</code> concurrently. Instead, using <code>defer</code> (with <code>self()</code>) will dispatch the method <em>back</em> to the <code>Master</code> process to be executed at a later point in time within the single-threaded execution context of the <code>Master</code>. Using <code>defer</code> here precisely allows us to capture these semantics.</p>
<p>A natural question that folks often ask is whether or not we ever <em>don't</em> want to use <code>defer(self(), ...)</code>, or even just 'defer`. In some circumstances, you actually don't need to defer back to your own process, but you often want to defer. A good example of that is handling HTTP requests. Consider this example:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>process;</div><div class="line"></div><div class="line"><span class="keyword">using</span> std::string;</div><div class="line"></div><div class="line"><span class="keyword">class </span>HttpProcess : <span class="keyword">public</span> <a class="code" href="classprocess_1_1Process.html">Process</a>&lt;HttpProcess&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespaceprocess.html#a775933dc25b7d86ec1984e0c8cd9ee5f">initialize</a>()</div><div class="line">  {</div><div class="line">    route(<span class="stringliteral">&quot;/route&quot;</span>, <a class="code" href="structNone.html">None</a>(), [](<span class="keyword">const</span> <a class="code" href="structprocess_1_1http_1_1Request.html">http::Request</a>&amp; request) {</div><div class="line">      <span class="keywordflow">return</span> functionWhichReturnsAFutureOfString()</div><div class="line">        .then(<a class="code" href="namespaceprocess.html#a8b27a2ef76eb133bf0ce7a5eea4fb77c">defer</a>(<span class="keyword">self</span>(), [](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; s) {</div><div class="line">          <span class="keywordflow">return</span> <a class="code" href="structprocess_1_1http_1_1OK.html">http::OK</a>(<span class="stringliteral">&quot;String returned in body: &quot;</span> + s);</div><div class="line">        }));</div><div class="line">    });</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>Now, while this is totally legal and correct code, the callback executed after <code>functionWhichReturnsAFutureOfString</code> is completed <em>does not</em> need to be executed within the execution context of <code>HttpProcess</code> because it doesn't require any state from <code>HttpProcess</code>! In this case, rather than forcing the execution of the callback within the execution context of <code>HttpProcess</code>, which will block other callbacks <em>that must</em> be executed by <code>HttpProcess</code>, we can simply just run this lambda using an execution context that libprocess can pick for us (from a pool of threads). We do so by removing <code>self()</code> as the first argument to <code>defer</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>process;</div><div class="line"></div><div class="line"><span class="keyword">using</span> std::string;</div><div class="line"></div><div class="line"><span class="keyword">class </span>HttpProcess : <span class="keyword">public</span> <a class="code" href="classprocess_1_1Process.html">Process</a>&lt;HttpProcess&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespaceprocess.html#a775933dc25b7d86ec1984e0c8cd9ee5f">initialize</a>()</div><div class="line">  {</div><div class="line">    route(<span class="stringliteral">&quot;/route&quot;</span>, <a class="code" href="structNone.html">None</a>(), [](<span class="keyword">const</span> <a class="code" href="structprocess_1_1http_1_1Request.html">http::Request</a>&amp; request) {</div><div class="line">      <span class="keywordflow">return</span> functionWhichReturnsAFutureOfString()</div><div class="line">        .then(<a class="code" href="namespaceprocess.html#a8b27a2ef76eb133bf0ce7a5eea4fb77c">defer</a>([](<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; s) {</div><div class="line">          <span class="keywordflow">return</span> <a class="code" href="structprocess_1_1http_1_1OK.html">http::OK</a>(<span class="stringliteral">&quot;String returned in body: &quot;</span> + s);</div><div class="line">        }));</div><div class="line">    });</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><em>Note that even in this example</em> we still want to use <code>defer</code>! Why? Because otherwise we are blocking the execution context (i.e., process, thread, etc) that is <em>completing</em> the future because it is synchronously executing the callbacks! Instead, we want to let the callback get executed asynchronously by using <code>defer.</code></p>
<p>Let's construct a simple example that illustrates a problem that can be introduced by omitting <code>defer</code> from callback registrations. We'll define a method for our <code>HttpProcess</code> class which accepts an input string and returns a future via an asyncronous method called <code>asyncStoreData</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>process;</div><div class="line"></div><div class="line"><span class="keyword">using</span> std::string;</div><div class="line"></div><div class="line"><span class="keyword">class </span>HttpProcess : <span class="keyword">public</span> <a class="code" href="classprocess_1_1Process.html">Process</a>&lt;HttpProcess&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="comment">// Returns the number of bytes stored.</span></div><div class="line">  <a class="code" href="classprocess_1_1Future.html">Future&lt;int&gt;</a> inputHandler(<span class="keyword">const</span> <span class="keywordtype">string</span> input);</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="comment">// Returns the number of bytes stored.</span></div><div class="line">  <a class="code" href="classprocess_1_1Future.html">Future&lt;int&gt;</a> asyncStoreData(<span class="keyword">const</span> <span class="keywordtype">string</span> input);</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> storedCount;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classprocess_1_1Future.html">Future&lt;int&gt;</a> HttpProcess::inputHandler(<span class="keyword">const</span> <span class="keywordtype">string</span> input)</div><div class="line">{</div><div class="line">  LOG(INFO) &lt;&lt; <span class="stringliteral">&quot;HttpProcess received input: &quot;</span> &lt;&lt; input;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> asyncStoreData(input)</div><div class="line">    .<a class="code" href="classprocess_1_1Future.html#a08f6977c10f9f5d9e918ef8fd91f0a5f">then</a>([<span class="keyword">this</span>](<span class="keywordtype">int</span> bytes) -&gt; <a class="code" href="classprocess_1_1Future.html">Future&lt;int&gt;</a> {</div><div class="line">      this-&gt;storedCount += bytes;</div><div class="line"></div><div class="line">      LOG(INFO) &lt;&lt; <span class="stringliteral">&quot;Successfully stored input. &quot;</span></div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Total bytes stored so far: &quot;</span> &lt;&lt; this-&gt;storedCount;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> bytes;</div><div class="line">    });</div><div class="line">}</div></div><!-- fragment --><p>When the callback is registered on the <code>Future&lt;int&gt;</code> returned by <code>asyncStoreData</code>, a lambda is passed directly to <code>then</code>. This means that the lambda will be executed in whatever execution context eventually fulfills the future. If the future is fulfilled in a different execution context (i.e., inside a different libprocess process), then it's possible that the instance of <code>HttpProcess</code> that originally invoked <code>inputHandler</code> will have been destroyed, making <code>this</code> a dangling pointer. In order to avoid this possibility, the callback should be registered as follows:</p>
<div class="fragment"><div class="line"><span class="keywordflow">return</span> asyncStoreData(input)</div><div class="line">  .then(<a class="code" href="namespaceprocess.html#a8b27a2ef76eb133bf0ce7a5eea4fb77c">defer</a>(<span class="keyword">self</span>(), [<span class="keyword">this</span>](<span class="keywordtype">int</span> bytes) -&gt; Future&lt;int&gt; {</div><div class="line">    ...</div><div class="line">  }));</div></div><!-- fragment --><p>The lambda is then guaranteed to execute within the execution context of the current process, and we know that <code>this</code> will still be a valid pointer. We should write libprocess code that makes no assumptions about the execution context in which a given future is fulfilled. Even if we can verify that a future will be fulfilled in the current process, registering a callback without <code>defer</code> makes the code more fragile by allowing the possibility that another contributor will make changes without considering the impact of those changes on the registered callbacks' execution contexts. Thus, <code>defer</code> should always be used. We offer the following rule to determine which form of <code>defer</code> should be used in a given situation:</p>
<ul>
<li>If the callback being registered accesses the state of a process, then it should be registered using <code>defer(pid, callback)</code>, where <code>pid</code> is the PID of the process whose state is being accessed.</li>
<li>If the callback doesn't access any process state, or only makes use of process variables that are captured <em>by value</em> so that the context of the process is not directly accessed when the callback is executed, then it can be run in an arbitrary execution context chosen by libprocess, and it should be registered using <code>defer(callback)</code>.</li>
</ul>
<h3><code>ID</code></h3>
<p>Generates a unique identifier string given a prefix. This is used to provide <code>PID</code> names.</p>
<h3><code>PID</code></h3>
<p>A <code>PID</code> provides a level of indirection for naming a process without having an actual reference (pointer) to it (necessary for remote processes).</p>
<hr/>
<h2>Futures and Promises</h2>
<p>The <code>Future</code> and <code>Promise</code> primitives are used to enable programmers to write asynchronous, non-blocking, and highly concurrent software.</p>
<p>A <code>Future</code> acts as the read-side of a result which might be computed asynchronously. A <code>Promise</code>, on the other hand, acts as the write-side "container". We'll use some examples to explain the concepts.</p>
<p>First, you can construct a <code>Promise</code> of a particular type by doing the following:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>process;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <a class="code" href="classprocess_1_1Promise.html">Promise&lt;int&gt;</a> <a class="code" href="namespacemesos_1_1internal_1_1log_1_1protocol.html#a3b1f8bd7b18c51af9d1f58842950b545">promise</a>;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>A <code>Promise</code> is not copyable or assignable, in order to encourage strict ownership rules between processes (i.e., it's hard to reason about multiple actors concurrently trying to complete a <code>Promise</code>, even if it's safe to do so concurrently).</p>
<p>You can get a <code>Future</code> from a <code>Promise</code> using the <code>Promise::future()</code> method:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>process;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <a class="code" href="classprocess_1_1Promise.html">Promise&lt;int&gt;</a> <a class="code" href="namespacemesos_1_1internal_1_1log_1_1protocol.html#a3b1f8bd7b18c51af9d1f58842950b545">promise</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classprocess_1_1Future.html">Future&lt;int&gt;</a> future = promise.<a class="code" href="classprocess_1_1Promise.html#a8aef752d6c90cb11e58e3166b7592ef1">future</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>Note that the templated type of the future must be the exact same as the promise: you cannot create a covariant or contravariant future. Unlike <code>Promise</code>, a <code>Future</code> can be both copied and assigned:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>process;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <a class="code" href="classprocess_1_1Promise.html">Promise&lt;int&gt;</a> <a class="code" href="namespacemesos_1_1internal_1_1log_1_1protocol.html#a3b1f8bd7b18c51af9d1f58842950b545">promise</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classprocess_1_1Future.html">Future&lt;int&gt;</a> future = promise.<a class="code" href="classprocess_1_1Promise.html#a8aef752d6c90cb11e58e3166b7592ef1">future</a>();</div><div class="line"></div><div class="line">  <span class="comment">// You can copy a future.</span></div><div class="line">  <a class="code" href="classprocess_1_1Future.html">Future&lt;int&gt;</a> future2 = future;</div><div class="line"></div><div class="line">  <span class="comment">// You can also assign a future (NOTE: this future will never</span></div><div class="line">  <span class="comment">// complete because the Promise goes out of scope, but the</span></div><div class="line">  <span class="comment">// Future is still valid and can be used normally.)</span></div><div class="line">  future = <a class="code" href="classprocess_1_1Promise.html">Promise&lt;int&gt;</a>().future();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The result encapsulated in the <code>Future</code>/<code>Promise</code> can be in one of four states: <code>PENDING</code>, <code>READY</code>, <code>FAILED</code>, <code>DISCARDED</code>. When a <code>Promise</code> is first created the result is <code>PENDING</code>. When you complete a <code>Promise</code> using the <code><a class="el" href="namespacerouting_1_1link_1_1internal.html#abfdfc99e016fe858117fa1767cef2be0">Promise::set()</a></code> method the result becomes <code>READY</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>process;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <a class="code" href="classprocess_1_1Promise.html">Promise&lt;int&gt;</a> <a class="code" href="namespacemesos_1_1internal_1_1log_1_1protocol.html#a3b1f8bd7b18c51af9d1f58842950b545">promise</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classprocess_1_1Future.html">Future&lt;int&gt;</a> future = promise.<a class="code" href="classprocess_1_1Promise.html#a8aef752d6c90cb11e58e3166b7592ef1">future</a>();</div><div class="line"></div><div class="line">  promise.<a class="code" href="classprocess_1_1Promise.html#a989b8dfa7eb2633de3f0f25ac2b87943">set</a>(42);</div><div class="line"></div><div class="line">  CHECK(future.<a class="code" href="classprocess_1_1Future.html#a68f241961e700d0cecf982d9cc0043d7">isReady</a>());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><blockquote class="doxtable">
<p>NOTE: <code>CHECK</code> is a macro from <code>gtest</code> which acts like an <code>assert</code> but prints a stack trace and does better signal management. In addition to <code>CHECK</code>, we've also created wrapper macros <code>CHECK_PENDING</code>, <code>CHECK_READY</code>, <code>CHECK_FAILED</code>, <code>CHECK_DISCARDED</code> which enables you to more concisely do things like <code><a class="el" href="include_2process_2check_8hpp.html#acae435c0105396efafab64dd624f6490">CHECK_READY(future)</a></code> in your code. We'll use those throughout the rest of this guide. </p>
</blockquote>
<p>TODO(benh):</p><ul>
<li>Using <code>Future</code> and <code>Promise</code> between actors, i.e., <code>dispatch</code> returning a <code>Future</code></li>
<li><code>Promise::fail()</code></li>
<li><code><a class="el" href="namespaceprocess_1_1internal.html#a58d2ee086b173d21a4fc0550f843dd2e">Promise::discard()</a></code> and <code><a class="el" href="namespaceprocess_1_1internal.html#a58d2ee086b173d21a4fc0550f843dd2e">Future::discard()</a></code></li>
<li><code>Future::onReady()</code>, <code>Future::onFailed()</code>, <code>Future::onDiscarded()</code></li>
<li><code><a class="el" href="namespaceprocess_1_1internal.html#ac8039d54d4112dd09a7c1edc644e8572">Future::then()</a></code>, <code><a class="el" href="namespaceprocess_1_1internal.html#a86c36ee36d231da3645dc12571f1d25a">Future::repair()</a></code>, <code>Future::after</code></li>
<li><code>defer</code></li>
<li><code><a class="el" href="namespaceprocess.html#a9244f063b856adbc7182f8620b01034c">Future::await()</a></code></li>
</ul>
<h2><code>HTTP</code></h2>
<p>libprocess provides facilities for communicating between actors via HTTP messages. With the advent of the HTTP API, HTTP is becoming the preferred mode of communication.</p>
<h3><code>route</code></h3>
<p><code>route</code> installs an HTTP endpoint onto a process. Let's define a simple process that installs an endpoint upon initialization:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>process;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceprocess_1_1http.html">process::http</a>;</div><div class="line"></div><div class="line"><span class="keyword">class </span>HttpProcess : <span class="keyword">public</span> <a class="code" href="classprocess_1_1Process.html">Process</a>&lt;HttpProcess&gt;</div><div class="line">{</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespaceprocess.html#a775933dc25b7d86ec1984e0c8cd9ee5f">initialize</a>()</div><div class="line">  {</div><div class="line">    route(<span class="stringliteral">&quot;/testing&quot;</span>, <a class="code" href="structNone.html">None</a>(), [](<span class="keyword">const</span> <a class="code" href="structprocess_1_1http_1_1Request.html">Request</a>&amp; request) {</div><div class="line">      <span class="keywordflow">return</span> testing(request.query);</div><div class="line">    });</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class </span>Http</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Http() : process(new HttpProcess())</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceprocess.html#aff22904a83567125d3b4d0d88e5a2270">spawn</a>(process.get());</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> ~Http()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceprocess.html#a20443908afa3212215166e26065349e5">terminate</a>(process.get());</div><div class="line">    <a class="code" href="namespaceprocess.html#a07833fb41a8b0c1f18fa5485ca8c18d4">wait</a>(process.get());</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="classprocess_1_1Owned.html">Owned&lt;HttpProcess&gt;</a> <a class="code" href="namespaceos.html#ae19e4161a51b86a1f330f3bf1dc75389">process</a>;</div><div class="line">};</div></div><!-- fragment --><p>Now if our program instantiates this class, we can do something like: <code>$ curl localhost:1234/testing?value=42</code></p>
<p>Note that the port at which this endpoint can be reached is the port libprocess has bound to, which is determined by the <code>LIBPROCESS_PORT</code> environment variable. In the case of the Mesos master or agent, this environment variable is set according to the <code>--port</code> command-line flag.</p>
<h3><code>get</code></h3>
<p><code>get</code> will hit an HTTP endpoint with a GET request and return a <code>Future</code> containing the response. We can pass it either a libprocess <code>UPID</code> or a <code>URL</code>. Here's an example hitting the endpoint assuming we have a <code>UPID</code> named <code>upid</code>:</p>
<div class="fragment"><div class="line">Future&lt;Response&gt; future = <span class="keyword">get</span>(upid, <span class="stringliteral">&quot;testing&quot;</span>);</div></div><!-- fragment --><p>Or let's assume our serving process has been set up on a remote server and we want to hit its endpoint. We'll construct a <code>URL</code> for the address and then call <code>get</code>:</p>
<div class="fragment"><div class="line">URL url = URL(<span class="stringliteral">&quot;http&quot;</span>, <span class="stringliteral">&quot;hostname&quot;</span>, 1234, <span class="stringliteral">&quot;/testing&quot;</span>);</div><div class="line"></div><div class="line">Future&lt;Response&gt; future = <span class="keyword">get</span>(url);</div></div><!-- fragment --><h3><code>post</code> and <code>requestDelete</code></h3>
<p>The <code>post</code> and <code>requestDelete</code> functions will similarly send POST and DELETE requests to an HTTP endpoint. Their invocation is analogous to <code>get</code>.</p>
<h3><code>Connection</code></h3>
<p>A <code>Connection</code> represents a connection to an HTTP server. <code>connect</code> can be used to connect to a server, and returns a <code>Future</code> containing the <code>Connection</code>. Let's open a connection to a server and send some requests:</p>
<div class="fragment"><div class="line">Future&lt;Connection&gt; <a class="code" href="namespaceprocess_1_1http.html#a10ffcbef96dbc1f9aac1dcf90d2c642d">connect</a> = <a class="code" href="namespaceprocess_1_1http.html#a10ffcbef96dbc1f9aac1dcf90d2c642d">connect</a>(url);</div><div class="line"></div><div class="line">connect.await();</div><div class="line"></div><div class="line">Connection connection = connect.get();</div><div class="line"></div><div class="line">Request request;</div><div class="line">request.<a class="code" href="structprocess_1_1http_1_1Request.html#a2e81202fca3244a7de00ac7bb253d59d">method</a> = <span class="stringliteral">&quot;GET&quot;</span>;</div><div class="line">request.url = url;</div><div class="line">request.body = <span class="stringliteral">&quot;Amazing prose goes here.&quot;</span>;</div><div class="line">request.keepAlive = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">Future&lt;Response&gt; response = connection.send(request);</div></div><!-- fragment --><p>It's also worth noting that if multiple requests are sent in succession on a <code>Connection</code>, they will be automatically pipelined.</p>
<h2>Clock Management and Timeouts</h2>
<p>Asynchronous programs often use timeouts, e.g., because a process that initiates an asynchronous operation wants to take action if the operation hasn't completed within a certain time bound. To facilitate this, libprocess provides a set of abstractions that simplify writing timeout logic. Importantly, test code has the ability to manipulate the clock, in order to ensure that timeout logic is exercised (without needing to block the test program until the appropriate amount of system time has elapsed).</p>
<p>To invoke a function after a certain amount of time has elapsed, use <code>delay</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>process;</div><div class="line"></div><div class="line"><span class="keyword">class </span>DelayedProcess : <span class="keyword">public</span> <a class="code" href="classprocess_1_1Process.html">Process</a>&lt;DelayedProcess&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span> action(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; <a class="code" href="namespacerouting_1_1link.html#a92ef360196f329e41575de0f7a094a6e">name</a>)</div><div class="line">  {</div><div class="line">    LOG(INFO) &lt;&lt; <span class="stringliteral">&quot;hello, &quot;</span> &lt;&lt; <a class="code" href="namespacerouting_1_1link.html#a92ef360196f329e41575de0f7a094a6e">name</a>;</div><div class="line"></div><div class="line">    promise.<a class="code" href="classprocess_1_1Promise.html#a989b8dfa7eb2633de3f0f25ac2b87943">set</a>(<a class="code" href="structNothing.html">Nothing</a>());</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="classprocess_1_1Promise.html">Promise&lt;Nothing&gt;</a> <a class="code" href="namespacemesos_1_1internal_1_1log_1_1protocol.html#a3b1f8bd7b18c51af9d1f58842950b545">promise</a>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  DelayedProcess <a class="code" href="namespaceos.html#ae19e4161a51b86a1f330f3bf1dc75389">process</a>;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceprocess.html#aff22904a83567125d3b4d0d88e5a2270">spawn</a>(process);</div><div class="line"></div><div class="line">  LOG(INFO) &lt;&lt; <span class="stringliteral">&quot;Starting to wait&quot;</span>;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceprocess.html#ad46335bec9fe626e60003c33e8f13023">delay</a>(<a class="code" href="classSeconds.html">Seconds</a>(5), process.self(), &amp;DelayedProcess::action, <span class="stringliteral">&quot;Neil&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="include_2process_2gtest_8hpp.html#a40053e3b018990adc509382682c7c3cc">AWAIT_READY</a>(process.promise.future());</div><div class="line"></div><div class="line">  LOG(INFO) &lt;&lt; <span class="stringliteral">&quot;Done waiting&quot;</span>;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceprocess.html#a20443908afa3212215166e26065349e5">terminate</a>(process);</div><div class="line">  <a class="code" href="namespaceprocess.html#a07833fb41a8b0c1f18fa5485ca8c18d4">wait</a>(process);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This invokes the <code>action</code> function after (at least) five seconds of time have elapsed. When writing unit tests for this code, blocking the test for five seconds is undesirable. To avoid this, we can use <code>Clock::advance</code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  DelayedProcess <a class="code" href="namespaceos.html#ae19e4161a51b86a1f330f3bf1dc75389">process</a>;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceprocess.html#aff22904a83567125d3b4d0d88e5a2270">spawn</a>(process);</div><div class="line"></div><div class="line">  LOG(INFO) &lt;&lt; <span class="stringliteral">&quot;Starting to wait&quot;</span>;</div><div class="line"></div><div class="line">  Clock::pause();</div><div class="line"></div><div class="line">  <a class="code" href="namespaceprocess.html#ad46335bec9fe626e60003c33e8f13023">delay</a>(<a class="code" href="classSeconds.html">Seconds</a>(5), process.self(), &amp;DelayedProcess::action, <span class="stringliteral">&quot;Neil&quot;</span>);</div><div class="line"></div><div class="line">  Clock::advance(<a class="code" href="classSeconds.html">Seconds</a>(5));</div><div class="line"></div><div class="line">  <a class="code" href="include_2process_2gtest_8hpp.html#a40053e3b018990adc509382682c7c3cc">AWAIT_READY</a>(process.promise.future());</div><div class="line"></div><div class="line">  LOG(INFO) &lt;&lt; <span class="stringliteral">&quot;Done waiting&quot;</span>;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceprocess.html#a20443908afa3212215166e26065349e5">terminate</a>(process);</div><div class="line">  <a class="code" href="namespaceprocess.html#a07833fb41a8b0c1f18fa5485ca8c18d4">wait</a>(process);</div><div class="line"></div><div class="line">  Clock::resume();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2>Miscellaneous Primitives</h2>
<h3><code>async</code></h3>
<p>Async defines a function template for asynchronously executing function closures. It provides their results as <a href="#futures-and-promises">futures</a>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
