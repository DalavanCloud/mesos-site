<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Apache Mesos: /local/mesos/mesos.master/3rdparty/libprocess/3rdparty/stout/include/stout/synchronized.hpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Mesos
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">/local/mesos/mesos.master/3rdparty/libprocess/3rdparty/stout/include/stout/synchronized.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<p>Waits on the 'std::condition_variable' associated with 'std::mutex' which has already been synchronized. We provide this specialization since 'std::condition_variable::wait' only works with 'std::unique_lock&lt;std::mutex&gt;'.</p>
<p>std::condition_variable cv; std::mutex m; synchronized (m) { // lock 'm'. // ... synchronized_wait(cv, m); // unlock/lock 'm'. // ... } // unlock 'm'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cv</td><td>The 'std::condition_variable'. </td></tr>
    <tr><td class="paramname">mutex</td><td>The 'std::mutex' associated with the 'std::condition_variable'.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>'mutex' is already owned by the calling thread. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>'mutex' is still owned by the calling thread.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structNothing.html">Nothing</a>.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></div><div class="line"><span class="comment">// you may not use this file except in compliance with the License.</span></div><div class="line"><span class="comment">// You may obtain a copy of the License at</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//  http://www.apache.org/licenses/LICENSE-2.0</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Unless required by applicable law or agreed to in writing, software</span></div><div class="line"><span class="comment">// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></div><div class="line"><span class="comment">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></div><div class="line"><span class="comment">// See the License for the specific language governing permissions and</span></div><div class="line"><span class="comment">// limitations under the License.</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifndef __STOUT_SYNCHRONIZED_HPP__</span></div><div class="line"><span class="preprocessor">#define __STOUT_SYNCHRONIZED_HPP__</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;atomic&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;condition_variable&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;mutex&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;type_traits&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;glog/logging.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="preprocessor_8hpp.html">stout/preprocessor.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// An RAII class for the &#39;synchronized(m)&#39; macro.</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">class </span><a name="_a0"></a><a class="code" href="classSynchronized.html">Synchronized</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">explicit</span> <a name="a1"></a><a class="code" href="classSynchronized.html#a6f1fcefdbc244929d3a3efce643d1a42">Synchronized</a>(T* t, <span class="keywordtype">void</span> (*acquire)(T*), <span class="keywordtype">void</span> (*<a name="a2"></a><a class="code" href="namespaceos.html#a9b48fd868f0b0dfb37a4a21edc5c5b0e">release</a>)(T*))</div><div class="line">    : t_(CHECK_NOTNULL(t)), release_(<a class="code" href="namespaceos.html#a9b48fd868f0b0dfb37a4a21edc5c5b0e">release</a>)</div><div class="line">  {</div><div class="line">    acquire(t_);</div><div class="line">  }</div><div class="line"></div><div class="line">  <a name="a3"></a><a class="code" href="classSynchronized.html#aecbfeefc61737bdcc3f0c010cdb62c07">~Synchronized</a>() { release_(t_); }</div><div class="line"></div><div class="line">  <span class="comment">// NOTE: &#39;false&#39; being returned here has no significance.</span></div><div class="line">  <span class="comment">//       Refer to the NOTE for &#39;synchronized&#39; at the bottom for why.</span></div><div class="line">  <span class="keyword">explicit</span> <span class="keyword">operator</span> bool()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">false</span>; }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  T* t_;</div><div class="line"></div><div class="line">  void (*release_)(T*);</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// The generic version handles mutexes which have &#39;lock&#39; and &#39;unlock&#39;</span></div><div class="line"><span class="comment">// member functions such as &#39;std::mutex&#39; and &#39;std::recursive_mutex&#39;.</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><a class="code" href="classSynchronized.html">Synchronized&lt;T&gt;</a> <a name="a4"></a><a class="code" href="synchronized_8hpp.html#ab47019f16d58f080f2b323b5b586e55d">synchronize</a>(T* t)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="classSynchronized.html">Synchronized&lt;T&gt;</a>(</div><div class="line">    t,</div><div class="line">    [](T* t) { t-&gt;lock(); },</div><div class="line">    [](T* t) { t-&gt;unlock(); }</div><div class="line">  );</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// An overload of the &#39;synchronize&#39; function for &#39;std::atomic_flag&#39;.</span></div><div class="line"><span class="keyword">inline</span> <a class="code" href="classSynchronized.html">Synchronized&lt;std::atomic_flag&gt;</a> <a class="code" href="synchronized_8hpp.html#ab47019f16d58f080f2b323b5b586e55d">synchronize</a>(std::atomic_flag* lock)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="classSynchronized.html">Synchronized&lt;std::atomic_flag&gt;</a>(</div><div class="line">    lock,</div><div class="line">    [](std::atomic_flag* lock) {</div><div class="line">      <span class="keywordflow">while</span> (lock-&gt;test_and_set(std::memory_order_acquire)) {}</div><div class="line">    },</div><div class="line">    [](std::atomic_flag* lock) {</div><div class="line">      lock-&gt;clear(std::memory_order_release);</div><div class="line">    }</div><div class="line">  );</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">T* <a name="a5"></a><a class="code" href="synchronized_8hpp.html#a4ec79edd13ce87b72eae3ba83b34ad14">synchronized_get_pointer</a>(T** t)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> *CHECK_NOTNULL(t);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">T* <a class="code" href="synchronized_8hpp.html#a4ec79edd13ce87b72eae3ba83b34ad14">synchronized_get_pointer</a>(T* t)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> t;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Macros to help generate &quot;unique&quot; identifiers for the</span></div><div class="line"><span class="comment">// synchronization variable name and label. The line number gets</span></div><div class="line"><span class="comment">// embedded which makes it unique enough, but not absolutely unique.</span></div><div class="line"><span class="comment">// It shouldn&#39;t be a problem however, since it&#39;s very unlikely that</span></div><div class="line"><span class="comment">// anyone would place multiple &#39;synchronized&#39; blocks on one line.</span></div><div class="line"><span class="preprocessor">#define SYNCHRONIZED_PREFIX CAT(__synchronizer_, __LINE__)</span></div><div class="line"><span class="preprocessor">#define SYNCHRONIZED_VAR CAT(SYNCHRONIZED_PREFIX, _var__)</span></div><div class="line"><span class="preprocessor">#define SYNCHRONIZED_LABEL CAT(SYNCHRONIZED_PREFIX, _label__)</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// A macro for acquiring a scoped &#39;guard&#39; on any type that can satisfy</span></div><div class="line"><span class="comment">// the &#39;Synchronized&#39; interface. We support &#39;std::mutex&#39;,</span></div><div class="line"><span class="comment">// &#39;std::recursive_mutex&#39; and &#39;std::atomic_flag&#39; by default.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//   Example usage:</span></div><div class="line"><span class="comment">//     std::mutex m;</span></div><div class="line"><span class="comment">//     synchronized (m) {</span></div><div class="line"><span class="comment">//       // Do something under the lock.</span></div><div class="line"><span class="comment">//     }</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// You can easily extend support for your synchronization primitive</span></div><div class="line"><span class="comment">// here, by overloading the &#39;synchronize&#39; function.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//   Example overload:</span></div><div class="line"><span class="comment">//     inline Synchronized&lt;bufferevent&gt; synchronize(bufferevent* bev)</span></div><div class="line"><span class="comment">//     {</span></div><div class="line"><span class="comment">//       return Synchronized&lt;bufferevent&gt;(</span></div><div class="line"><span class="comment">//         bev,</span></div><div class="line"><span class="comment">//         [](bufferevent* bev) { bufferevent_lock(bev); },</span></div><div class="line"><span class="comment">//         [](bufferevent* bev) { bufferevent_unlock(bev); },</span></div><div class="line"><span class="comment">//       );</span></div><div class="line"><span class="comment">//     }</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// How it works: An instance of the synchronization primitive is</span></div><div class="line"><span class="comment">// constructed inside the &#39;condition&#39; of if statement. This variable</span></div><div class="line"><span class="comment">// stays alive for the lifetime of the block. The trick with &#39;goto&#39;,</span></div><div class="line"><span class="comment">// &#39;else&#39; and the label allows the compiler to figure out that the</span></div><div class="line"><span class="comment">// synchronized block will always execute. This allows us to return</span></div><div class="line"><span class="comment">// within the synchronized block and avoid the</span></div><div class="line"><span class="comment">// &#39;control reaches the end of a non-void function&#39; warning.</span></div><div class="line"><span class="comment">// Note that the variable declared inside the &#39;condition&#39; of an if</span></div><div class="line"><span class="comment">// statement is guaranteed to live through the &#39;else&#39; clause as well.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// From Section 6.4.3:</span></div><div class="line"><span class="comment">//   A name introduced by a declaration in a condition (either</span></div><div class="line"><span class="comment">//   introduced by the decl-specifier-seq or the declarator of the</span></div><div class="line"><span class="comment">//   condition) is in scope from its point of declaration until the</span></div><div class="line"><span class="comment">//   end of the substatements controlled by the condition.</span></div><div class="line"><span class="preprocessor">#define synchronized(m)                                                     \</span></div><div class="line"><span class="preprocessor">  if (Synchronized&lt;typename std::remove_pointer&lt;decltype(m)&gt;::type&gt;         \</span></div><div class="line"><span class="preprocessor">        SYNCHRONIZED_VAR = ::synchronize(::synchronized_get_pointer(&amp;m))) { \</span></div><div class="line"><span class="preprocessor">    goto SYNCHRONIZED_LABEL;                                                \</span></div><div class="line"><span class="preprocessor">  } else SYNCHRONIZED_LABEL:</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CV, <span class="keyword">typename</span> Lock&gt;</div><div class="line"><span class="keywordtype">void</span> <a name="a6"></a><a class="code" href="synchronized_8hpp.html#a9d854e5436a64744a231418cde397b05">synchronized_wait</a>(CV* cv, Lock* lock);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="synchronized_8hpp.html#a9d854e5436a64744a231418cde397b05">synchronized_wait</a>(std::condition_variable* cv, std::mutex* mutex)</div><div class="line">{</div><div class="line">  CHECK_NOTNULL(cv);</div><div class="line">  CHECK_NOTNULL(mutex);</div><div class="line"></div><div class="line">  <span class="comment">// Since the pre-condition is that &#39;mutex&#39; is already owned by the</span></div><div class="line">  <span class="comment">// calling thread, we use &#39;std::adopt_lock&#39; to adopt the mutex</span></div><div class="line">  <span class="comment">// rather than trying to lock it ourselves.</span></div><div class="line">  std::unique_lock&lt;std::mutex&gt; lock(*mutex, std::adopt_lock);</div><div class="line"></div><div class="line">  <span class="comment">// On entrance, &#39;std::condition_variable::wait&#39; releases &#39;mutex&#39;.</span></div><div class="line">  <span class="comment">// On exit, &#39;std::condition_variable::wait&#39; re-acquires &#39;mutex&#39;.</span></div><div class="line">  cv-&gt;wait(lock);</div><div class="line"></div><div class="line">  <span class="comment">// At this point, the &#39;mutex&#39; has been acquired. Since the</span></div><div class="line">  <span class="comment">// post-condition is that &#39;mutex&#39; is still owned by the calling</span></div><div class="line">  <span class="comment">// thread, we use &#39;release&#39; in order to prevent &#39;std::unique_lock&#39;</span></div><div class="line">  <span class="comment">// from unlocking the &#39;mutex&#39;.</span></div><div class="line">  lock.release();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Lock&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="synchronized_8hpp.html#a9d854e5436a64744a231418cde397b05">synchronized_wait</a>(std::condition_variable_any* cv, Lock* lock) = <span class="keyword">delete</span>;</div><div class="line"></div><div class="line"><span class="preprocessor">#endif // __STOUT_SYNCHRONIZED_HPP__</span></div></div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
