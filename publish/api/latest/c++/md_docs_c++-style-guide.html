<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Apache Mesos: c++-style-guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Mesos
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">c++-style-guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr/>
 <h2>layout: documentation </h2>
<h1>Mesos C++ Style Guide</h1>
<p>The Mesos codebase follows the <a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml">Google C++ Style Guide</a> with some notable differences, as described below. Note that the <a class="el" href="clang-format_8md.html">clang-format</a> tool can be helpful to ensure that some of the mechanical style rules are obeyed.</p>
<h2>Scoping</h2>
<h3>Namespaces</h3>
<ul>
<li>We avoid <code>using namespace foo</code> statements as it is not explicit about which symbols are pulled in, and it can often pull in a lot of symbols, which sometimes lead to conflicts.</li>
<li>It is OK to use namespace aliases to help pull in sub-namespaces, such as <code>namespace http = <a class="el" href="namespaceprocess_1_1http.html">process::http</a>;</code>. These should only be present at the top of the .cpp file.</li>
</ul>
<h2>Naming</h2>
<h3>Variable Names</h3>
<ul>
<li>We use <a href="http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms">lowerCamelCase</a> for variable names (Google uses snake_case, and their class member variables have trailing underscores).</li>
<li>We prepend constructor and function arguments with a leading underscore to avoid ambiguity and / or shadowing:</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="classTry.html">Try</a>(State _state, T* _t = NULL, <span class="keyword">const</span> std::string&amp; _message = <span class="stringliteral">&quot;&quot;</span>)</div><div class="line">  : state(_state), t(_t), message(_message) {}</div></div><!-- fragment --><ul>
<li>Prefer trailing underscores for use as member fields (but not required). Some trailing underscores are used to distinguish between similar variables in the same scope (think prime symbols), <em>but this should be avoided as much as possible, including removing existing instances in the code base.</em></li>
<li>If you find yourself creating a copy of an argument passed by const reference, consider passing it by value instead (if you don't want to use a leading underscore and copy in the body of the function):</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// You can pass-by-value in ProtobufProcess::install() handlers.</span></div><div class="line"><span class="keywordtype">void</span> Slave::statusUpdate(StatusUpdate <a class="code" href="namespacerouting_1_1filter_1_1basic.html#a088d88712e011acb0673da92045b365b">update</a>, <span class="keyword">const</span> UPID&amp; pid)</div><div class="line">{</div><div class="line">  ...</div><div class="line">  update.mutable_status()-&gt;set_source(</div><div class="line">      pid == UPID() ? TaskStatus::SOURCE_SLAVE : TaskStatus::SOURCE_EXECUTOR);</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><h3>Constant Names</h3>
<ul>
<li>We use <a href="http://en.wikipedia.org/wiki/Letter_case#Special_case_styles">SCREAMING_SNAKE_CASE</a> for constant names (Google uses a <code>k</code> followed by mixed case, e.g. <code>kDaysInAWeek</code>).</li>
</ul>
<h3>Function Names</h3>
<ul>
<li>We use <a href="http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms">lowerCamelCase</a> for function names (Google uses mixed case for regular functions; and their accessors and mutators match the name of the variable).</li>
</ul>
<h2>Strings</h2>
<ul>
<li>Strings used in log and error messages should end without a period.</li>
</ul>
<h2>Comments</h2>
<ul>
<li>End each sentence within a comment with a punctuation mark (please note that we generally prefer periods); this applies to incomplete sentences as well.</li>
<li>For trailing comments, leave one space.</li>
<li>Use backticks when quoting code excerpts or object/variable/function names. For example:</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Use `SchedulerDriver::acceptOffers()` to send several offer</span></div><div class="line"><span class="comment">// operations. This makes use of the `RESERVE()` and `UNRESERVE()`</span></div><div class="line"><span class="comment">// helpers, which take a `Resources` object as input and produce</span></div><div class="line"><span class="comment">// appropriate offer operations. Note that we are unreserving the</span></div><div class="line"><span class="comment">// resources contained in `dynamicallyReserved1`.</span></div><div class="line">driver.acceptOffers({offer.id()},</div><div class="line">    {<a class="code" href="namespacemesos_1_1internal_1_1tests.html#af87b543b54b98a64626e84c9e8fff2c3">UNRESERVE</a>(dynamicallyReserved1),</div><div class="line">     <a class="code" href="namespacemesos_1_1internal_1_1tests.html#ab20e308f8d5a6369f741d662a80e047a">RESERVE</a>(dynamicallyReserved2),</div><div class="line">     <a class="code" href="namespacemesos_1_1internal_1_1tests.html#ab20e308f8d5a6369f741d662a80e047a">RESERVE</a>(dynamicallyReserved3)},</div><div class="line">    <a class="code" href="namespacerouting_1_1filter_1_1internal.html#a646d4e3238d83329525957b5a5586be2">filters</a>);</div></div><!-- fragment --><h2>Breaks</h2>
<ul>
<li>Break before braces on enum, function, and record (i.e. struct, class, union) definitions.</li>
</ul>
<h2>Indentation</h2>
<h3>Class Format</h3>
<ul>
<li>Access modifiers are not indented (Google uses one space indentation).</li>
<li>Constructor initializers are indented by two spaces (Google indents by four).</li>
</ul>
<h3>Templates</h3>
<ul>
<li>Leave one space after the <code>template</code> keyword, e.g. <code>template &lt;typename T&gt;</code> rather than <code>template&lt;typename T&gt;</code>.</li>
</ul>
<h3>Function Definition/Invocation</h3>
<ul>
<li>Newline when calling or defining a function: indent with four spaces.</li>
<li>We do not follow Google's style of wrapping on the open parenthesis, the general goal is to reduce visual "jaggedness" in the code. Prefer (1), (4), (5), sometimes (3), never (2):</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// 1: OK.</span></div><div class="line">allocator-&gt;resourcesRecovered(frameworkId, slaveId, resources, <a class="code" href="namespacerouting_1_1filter_1_1internal.html#a646d4e3238d83329525957b5a5586be2">filters</a>);</div><div class="line"></div><div class="line"><span class="comment">// 2: Don&#39;t use.</span></div><div class="line">allocator-&gt;resourcesRecovered(frameworkId, slaveId,</div><div class="line">                              resources, <a class="code" href="namespacerouting_1_1filter_1_1internal.html#a646d4e3238d83329525957b5a5586be2">filters</a>);</div><div class="line"></div><div class="line"><span class="comment">// 3: Don&#39;t use in this case due to &quot;jaggedness&quot;.</span></div><div class="line">allocator-&gt;resourcesRecovered(frameworkId,</div><div class="line">                              slaveId,</div><div class="line">                              resources,</div><div class="line">                              <a class="code" href="namespacerouting_1_1filter_1_1internal.html#a646d4e3238d83329525957b5a5586be2">filters</a>);</div><div class="line"></div><div class="line"><span class="comment">// 3: In this case, 3 is OK.</span></div><div class="line">foobar(someArgument,</div><div class="line">       someOtherArgument,</div><div class="line">       theLastArgument);</div><div class="line"></div><div class="line"><span class="comment">// 4: OK.</span></div><div class="line">allocator-&gt;resourcesRecovered(</div><div class="line">    frameworkId,</div><div class="line">    slaveId,</div><div class="line">    resources,</div><div class="line">    <a class="code" href="namespacerouting_1_1filter_1_1internal.html#a646d4e3238d83329525957b5a5586be2">filters</a>);</div><div class="line"></div><div class="line"><span class="comment">// 5: OK.</span></div><div class="line">allocator-&gt;resourcesRecovered(</div><div class="line">    frameworkId, slaveId, resources, <a class="code" href="namespacerouting_1_1filter_1_1internal.html#a646d4e3238d83329525957b5a5586be2">filters</a>);</div></div><!-- fragment --><h3>Continuation</h3>
<ul>
<li>Newline for an assignment statement: indent with two spaces.</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="classTry.html">Try&lt;Duration&gt;</a> failoverTimeout =</div><div class="line">  <a class="code" href="classDuration.html#a70f3ccdaba8dd6d0a1c2eddde1d1327a">Duration::create</a>(FrameworkInfo().failover_timeout());</div></div><!-- fragment --><h2>Empty Lines</h2>
<ul>
<li>One empty line at the end of the file.</li>
<li>Inside a code block, every multi-line statement should be followed by one empty line.</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="classTry.html">Try&lt;very_very_long_type&gt;</a> long_name =</div><div class="line">    ::protobuf::parse&lt;very_very_long_type&gt;(</div><div class="line">        request);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; very_very_long_expression();</div><div class="line">     i++) {</div><div class="line">  <span class="comment">// No empty line here for control constructs.</span></div><div class="line">}</div></div><!-- fragment --><ul>
<li>Elements outside classes (classes, structs, global functions, etc.) should be spaced apart by two empty lines.</li>
<li>Elements inside classes (member variables and functions) should not be spaced apart by more than one empty line.</li>
</ul>
<h2>Capture by Reference</h2>
<p>We disallow capturing <b>temporaries</b> by reference. See <a href="https://issues.apache.org/jira/browse/MESOS-2629">MESOS-2629</a> for the rationale.</p>
<div class="fragment"><div class="line">Future&lt;Nothing&gt; <a class="code" href="namespaceprocess.html#a03e9502d47e4c92f61e9bdcc40218941">f</a>() { <span class="keywordflow">return</span> <a class="code" href="structNothing.html">Nothing</a>(); }</div><div class="line">Future&lt;bool&gt; g() { <span class="keywordflow">return</span> <span class="keyword">false</span>; }</div><div class="line"></div><div class="line"><span class="keyword">struct </span>T</div><div class="line">{</div><div class="line">  T(<span class="keyword">const</span> <span class="keywordtype">char</span>* data) : data(data) {}</div><div class="line">  <span class="keyword">const</span> T&amp; member()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *<span class="keyword">this</span>; }</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* data;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// 1: Don&#39;t use.</span></div><div class="line"><span class="keyword">const</span> Future&lt;Nothing&gt;&amp; future = <a class="code" href="namespaceprocess.html#a03e9502d47e4c92f61e9bdcc40218941">f</a>();</div><div class="line"></div><div class="line"><span class="comment">// 1: Instead use.</span></div><div class="line"><span class="keyword">const</span> Future&lt;Nothing&gt; future = <a class="code" href="namespaceprocess.html#a03e9502d47e4c92f61e9bdcc40218941">f</a>();</div><div class="line"></div><div class="line"><span class="comment">// 2: Don&#39;t use.</span></div><div class="line"><span class="keyword">const</span> Future&lt;Nothing&gt;&amp; future = Future&lt;Nothing&gt;(<a class="code" href="structNothing.html">Nothing</a>());</div><div class="line"></div><div class="line"><span class="comment">// 2: Instead use.</span></div><div class="line"><span class="keyword">const</span> Future&lt;Nothing&gt; future = Future&lt;Nothing&gt;(<a class="code" href="structNothing.html">Nothing</a>());</div><div class="line"></div><div class="line"><span class="comment">// 3: Don&#39;t use.</span></div><div class="line"><span class="keyword">const</span> Future&lt;bool&gt;&amp; future = <a class="code" href="namespaceprocess.html#a03e9502d47e4c92f61e9bdcc40218941">f</a>().then(<a class="code" href="namespaceprocess_1_1network.html#a1462e45e6d3963f5347745518cf03324">lambda::bind</a>(g));</div><div class="line"></div><div class="line"><span class="comment">// 3: Instead use.</span></div><div class="line"><span class="keyword">const</span> Future&lt;bool&gt; future = <a class="code" href="namespaceprocess.html#a03e9502d47e4c92f61e9bdcc40218941">f</a>().then(<a class="code" href="namespaceprocess_1_1network.html#a1462e45e6d3963f5347745518cf03324">lambda::bind</a>(g));</div><div class="line"></div><div class="line"><span class="comment">// 4: Don&#39;t use (since the T that got constructed is a temporary!).</span></div><div class="line"><span class="keyword">const</span> T&amp; t = T(<span class="stringliteral">&quot;Hello&quot;</span>).member();</div><div class="line"></div><div class="line"><span class="comment">// 4: Preferred alias pattern (see below).</span></div><div class="line"><span class="keyword">const</span> T t(<span class="stringliteral">&quot;Hello&quot;</span>);</div><div class="line"><span class="keyword">const</span> T&amp; t_ = t.member();</div><div class="line"></div><div class="line"><span class="comment">// 4: Can also use.</span></div><div class="line"><span class="keyword">const</span> T t = T(<span class="stringliteral">&quot;Hello&quot;</span>).member();</div></div><!-- fragment --><p>We allow capturing non-temporaries by <em>constant reference</em> when the intent is to <b>alias</b>.</p>
<p>The goal is to make code more concise and improve readability. Use this if an expression referencing a field by <code>const</code> is:</p>
<ul>
<li>Used repeatedly.</li>
<li>Would benefit from a concise name to provide context for readability.</li>
<li>Will <b>not</b> be invalidated during the lifetime of the alias. Otherwise document this explicitly.</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="classhashmap.html">hashmap&lt;string, hashset&lt;int&gt;</a>&gt; <a class="code" href="namespacerouting_1_1link.html#a26486cdba01ef1c80706b1e07e8a6d3f">index</a>;</div><div class="line"></div><div class="line"><span class="comment">// 1: Ok.</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="classhashset.html">hashset&lt;int&gt;</a>&amp; values = index[2];</div><div class="line"></div><div class="line"><span class="comment">// 2: Ok.</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> iterator = index.begin(); iterator != index.end(); ++iterator) {</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classhashset.html">hashset&lt;int&gt;</a>&amp; values = iterator-&gt;second;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// 3: Ok.</span></div><div class="line"><a class="code" href="foreach_8hpp.html#a30b2e89f0b0754c8cd9554fca6321816">foreachpair</a> (<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; key, <span class="keyword">const</span> <a class="code" href="classhashset.html">hashset&lt;int&gt;</a>&amp; values, index) {}</div><div class="line"><a class="code" href="foreach_8hpp.html#a7a3e7f04575d773844d34e493d23da8d">foreachvalue</a> (<span class="keyword">const</span> <a class="code" href="classhashset.html">hashset&lt;int&gt;</a>&amp; values, index) {}</div><div class="line"><a class="code" href="foreach_8hpp.html#a8779422fd95c46547b4e68b43b5100af">foreachkey</a> (<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; key, index) {}</div><div class="line"></div><div class="line"><span class="comment">// 4: Avoid aliases in most circumstances as they can be dangerous.</span></div><div class="line"><span class="comment">//    This is an example of a dangling alias!</span></div><div class="line">vector&lt;string&gt; <a class="code" href="namespacestrings.html">strings</a>{<span class="stringliteral">&quot;hello&quot;</span>};</div><div class="line"></div><div class="line"><span class="keywordtype">string</span>&amp; s = <a class="code" href="namespacestrings.html">strings</a>[0];</div><div class="line"></div><div class="line"><a class="code" href="namespacestrings.html">strings</a>.erase(<a class="code" href="namespacestrings.html">strings</a>.begin());</div><div class="line"></div><div class="line">s += <span class="stringliteral">&quot;world&quot;</span>; <span class="comment">// THIS IS A DANGLING REFERENCE!</span></div></div><!-- fragment --><h2>File Headers</h2>
<ul>
<li>Mesos source files must contain the "ASF" header: <pre class="fragment">   // Licensed to the Apache Software Foundation (ASF) under one
   // or more contributor license agreements.  See the NOTICE file
   // distributed with this work for additional information
   // regarding copyright ownership.  The ASF licenses this file
   // to you under the Apache License, Version 2.0 (the
   // "License"); you may not use this file except in compliance
   // with the License.  You may obtain a copy of the License at
   //
   //     http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS,
   // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   // See the License for the specific language governing permissions and
   // limitations under the License.
</pre></li>
<li>Stout and libprocess source files must contain the "Apache License Version 2.0" header: <pre class="fragment">   // Licensed under the Apache License, Version 2.0 (the "License");
   // you may not use this file except in compliance with the License.
   // You may obtain a copy of the License at
   //
   //     http://www.apache.org/licenses/LICENSE-2.0
   //
   // Unless required by applicable law or agreed to in writing, software
   // distributed under the License is distributed on an "AS IS" BASIS,
   // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   // See the License for the specific language governing permissions and
   // limitations under the License
</pre></li>
</ul>
<h2>Order of includes</h2>
<p>In addition to the ordering rules from the Google style guide, Mesos related headers are separated into sections. Newline to separate each section. Mesos related headers in <code>include</code> directories are partitioned by their subfolders, sorted alphabetically, and included using brackets. Header in <code>src</code> directories are included afterwards, using the same rules but with quotes instead of brackets.</p>
<p>Example for <code>src/common/foo.cpp</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;common/foo.hpp&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;stdint.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/circular_buffer.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2mesos_2mesos_8hpp.html">mesos/mesos.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="type__utils_8hpp.html">mesos/type_utils.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2mesos_2module_2authenticator_8hpp.html">mesos/module/authenticator.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scheduler_2scheduler_8hpp.html">mesos/scheduler/scheduler.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="3rdparty_2libprocess_2include_2process_2http_8hpp.html">process/http.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="3rdparty_2libprocess_2include_2process_2protobuf_8hpp.html">process/protobuf.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="foreach_8hpp.html">stout/foreach.hpp</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hashmap_8hpp.html">stout/hashmap.hpp</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="build_8hpp.html">common/build.hpp</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="protobuf__utils_8hpp.html">common/protobuf_utils.hpp</a>&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="src_2master_2flags_8hpp.html">master/flags.hpp</a>&quot;</span></div></div><!-- fragment --><h2>C++11</h2>
<p>We support C++11 and require GCC 4.8+ or Clang 3.5+ compilers. The whitelist of supported C++11 features is:</p>
<ul>
<li>Static assertions.</li>
<li>Multiple right angle brackets.</li>
<li>Type inference (<code>auto</code> and <code>decltype</code>). The main goal is to increase code readability. This is safely the case if the exact same type omitted on the left is already fully stated on the right. Here are several examples:</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// 1: OK.</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> i = values.find(keys.front());</div><div class="line"><span class="comment">// Compare with</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">typename</span> map::iterator i = values.find(keys.front());</div><div class="line"></div><div class="line"><span class="comment">// 2: OK.</span></div><div class="line"><span class="keyword">auto</span> names = shared_ptr&lt;list&lt;string&gt;&gt;(<span class="keyword">new</span> list&lt;string&gt;());</div><div class="line"><span class="comment">// Compare with</span></div><div class="line">shared_ptr&lt;list&lt;string&gt;&gt; names = shared_ptr&lt;list&lt;string&gt;&gt;(<span class="keyword">new</span> list&lt;string&gt;());</div><div class="line"></div><div class="line"><span class="comment">// 3: Don&#39;t use.</span></div><div class="line"><span class="keyword">auto</span> authorizer = <a class="code" href="namespacecgroups.html#a2ecc89636706df947027a4c3c2100fbe">LocalAuthorizer::create</a>(acls);</div><div class="line"><span class="comment">// Compare with</span></div><div class="line"><a class="code" href="classTry.html">Try&lt;Owned&lt;LocalAuthorizer&gt;</a>&gt; authorizer = <a class="code" href="namespacecgroups.html#a2ecc89636706df947027a4c3c2100fbe">LocalAuthorizer::create</a>();</div></div><!-- fragment --><ul>
<li>Rvalue references.</li>
<li>Explicitly-defaulted functions.</li>
<li>Variadic templates.</li>
<li>Delegating constructors.</li>
<li>Mutexes.<ul>
<li><code>std::mutex</code></li>
<li><code>std::lock_guard&lt;std::mutex&gt;</code></li>
<li><code>std::unique_lock&lt;std::mutex&gt;</code></li>
</ul>
</li>
<li>Atomics (<code>std::atomic</code>)<ul>
<li>The standard defines a number of predefined typedefs for atomic types (e.g., <code>std::atomic_int</code>), in addition to <code>std::atomic&lt;T&gt;</code>. When a typedef is available, it should be preferred over explicit template specialization of <code>std::atomic&lt;T&gt;</code>.</li>
<li>When reading from and writing to atomic values, the <code>load</code> and <code>store</code> member functions should be used instead of the overloads of <code>operator T()</code> and <code>operator=</code>. Being explicit helps to draw the reader's attention to the fact that atomic values are being manipulated.</li>
</ul>
</li>
<li>Shared from this.<ul>
<li><code>class T : public std::enable_shared_from_this&lt;T&gt;</code></li>
<li><code>shared_from_this()</code></li>
</ul>
</li>
<li>Lambdas!<ul>
<li>Don't put a space between the capture list and the parameter list:</li>
</ul>
</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// 1: OK.</span></div><div class="line">[]() { ...; };</div><div class="line"></div><div class="line"><span class="comment">// 2: Don&#39;t use.</span></div><div class="line">[] () { ...; };</div></div><!-- fragment --><ul>
<li>Prefer default capture by value, explicit capture by value, then capture by reference. To avoid dangling-pointer bugs, <em>never</em> use default capture by reference:</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// 1: OK.</span></div><div class="line">[=]() { ... }; <span class="comment">// Default capture by value.</span></div><div class="line">[n]() { ... }; <span class="comment">// Explicit capture by value.</span></div><div class="line">[&amp;n]() { ... }; <span class="comment">// Explicit capture by reference.</span></div><div class="line">[=, &amp;n]() { ... }; <span class="comment">// Default capture by value, explicit capture by reference.</span></div><div class="line"></div><div class="line"><span class="comment">// 2: Don&#39;t use.</span></div><div class="line">[&amp;]() { ... }; <span class="comment">// Default capture by reference.</span></div></div><!-- fragment --><ul>
<li>Use <code>mutable</code> only when absolutely necessary.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// 1: OK.</span></div><div class="line">[]() <span class="keyword">mutable</span> { ...; };</div></div><!-- fragment --><ul>
<li>Feel free to ignore the return type by default, adding it as necessary to appease the compiler or be more explicit for the reader.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// 1: OK.</span></div><div class="line">[]() { <span class="keywordflow">return</span> <span class="keyword">true</span>; };</div><div class="line">[]() -&gt; <span class="keywordtype">bool</span> { <span class="keywordflow">return</span> ambiguous(); };</div></div><!-- fragment --><ul>
<li>Feel free to use <code>auto</code> when naming a lambda expression:</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// 1: OK.</span></div><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacelambda.html">lambda</a> = []() { ...; };</div></div><!-- fragment --><ul>
<li>Format lambdas similar to how we format functions and methods. Feel free to let lambdas be one-liners:</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// 1: OK.</span></div><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacelambda.html">lambda</a> = []() {</div><div class="line">  ...;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// 2: OK.</span></div><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacelambda.html">lambda</a> = []() { ...; };</div></div><!-- fragment --><ul>
<li>Feel free to inline lambdas within function arguments:</li>
</ul>
<div class="fragment"><div class="line">instance.method([]() {</div><div class="line">  ...;</div><div class="line">});</div></div><!-- fragment --><ul>
<li>Chain function calls on a newline after the closing brace of the lambda and the closing parenthesis of function call:</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// 1: OK.</span></div><div class="line">instance</div><div class="line">  .method([]() {</div><div class="line">    ...;</div><div class="line">  })</div><div class="line">  .<a class="code" href="namespaceprocess_1_1internal.html#ac8039d54d4112dd09a7c1edc644e8572">then</a>([]() { ...; })</div><div class="line">  .<a class="code" href="namespaceprocess_1_1internal.html#ac8039d54d4112dd09a7c1edc644e8572">then</a>([]() {</div><div class="line">    ...;</div><div class="line">  });</div><div class="line"></div><div class="line"><span class="comment">// 2: OK (when no chaining, compare to 1).</span></div><div class="line">instance.method([]() {</div><div class="line">  ...;</div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// 3: OK (if no &#39;instance.method&#39;).</span></div><div class="line"><span class="keyword">function</span>([]() {</div><div class="line">  ...;</div><div class="line">})</div><div class="line">.<a class="code" href="namespaceprocess_1_1internal.html#ac8039d54d4112dd09a7c1edc644e8572">then</a>([]() { ...; })</div><div class="line">.<a class="code" href="namespaceprocess_1_1internal.html#ac8039d54d4112dd09a7c1edc644e8572">then</a>([]() {</div><div class="line">  ...;</div><div class="line">});</div><div class="line"></div><div class="line"><span class="comment">// 3: OK (but prefer 1).</span></div><div class="line">instance.method([]() {</div><div class="line">  ...;</div><div class="line">})</div><div class="line">.<a class="code" href="namespaceprocess_1_1internal.html#ac8039d54d4112dd09a7c1edc644e8572">then</a>([]() { ...; })</div><div class="line">.<a class="code" href="namespaceprocess_1_1internal.html#ac8039d54d4112dd09a7c1edc644e8572">then</a>([]() {</div><div class="line">  ...;</div><div class="line">});</div></div><!-- fragment --><ul>
<li>Wrap capture lists independently of parameters, <em>use the same formatting as if the capture list were template parameters</em>:</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// 1: OK.</span></div><div class="line"><span class="keyword">function</span>([&amp;capture1, &amp;capture2, &amp;capture3](</div><div class="line">    <span class="keyword">const</span> T1&amp; p1, <span class="keyword">const</span> T2&amp; p2, <span class="keyword">const</span> T3&amp; p3) {</div><div class="line">  ...;</div><div class="line">});</div><div class="line"></div><div class="line"><span class="keyword">function</span>(</div><div class="line">    [&amp;capture1, &amp;capture2, &amp;capture3](</div><div class="line">        <span class="keyword">const</span> T1&amp; p1, <span class="keyword">const</span> T2&amp; p2, <span class="keyword">const</span> T3&amp; p3) {</div><div class="line">  ...;</div><div class="line">});</div><div class="line"></div><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacelambda.html">lambda</a> = [&amp;capture1, &amp;capture2, &amp;capture3](</div><div class="line">    <span class="keyword">const</span> T1&amp; p1, <span class="keyword">const</span> T2&amp; p2, <span class="keyword">const</span> T3&amp; p3) {</div><div class="line">  ...;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacelambda.html">lambda</a> =</div><div class="line">  [&amp;capture1, &amp;capture2, &amp;capture3](</div><div class="line">      <span class="keyword">const</span> T1&amp; p1, <span class="keyword">const</span> T2&amp; p2, <span class="keyword">const</span> T3&amp; p3) {</div><div class="line">  ...;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// 2: OK (when capture list is longer than 80 characters).</span></div><div class="line"><span class="keyword">function</span>([</div><div class="line">    &amp;capture1,</div><div class="line">    &amp;capture2,</div><div class="line">    &amp;capture3,</div><div class="line">    &amp;capture4](</div><div class="line">        <span class="keyword">const</span> T1&amp; p1, <span class="keyword">const</span> T2&amp; p2) {</div><div class="line">  ...;</div><div class="line">});</div><div class="line"></div><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacelambda.html">lambda</a> = [</div><div class="line">    &amp;capture1,</div><div class="line">    &amp;capture2,</div><div class="line">    &amp;capture3,</div><div class="line">    &amp;capture4](</div><div class="line">        <span class="keyword">const</span> T1&amp; p1, <span class="keyword">const</span> T2&amp; p2) {</div><div class="line">  ...;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// 3: OK (but prefer 2).</span></div><div class="line"><span class="keyword">function</span>([</div><div class="line">    &amp;capture1,</div><div class="line">    &amp;capture2,</div><div class="line">    &amp;capture3,</div><div class="line">    &amp;capture4](<span class="keyword">const</span> T1&amp; p1, <span class="keyword">const</span> T2&amp; t2) {</div><div class="line">  ...;</div><div class="line">});</div><div class="line"></div><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacelambda.html">lambda</a> = [</div><div class="line">    &amp;capture1,</div><div class="line">    &amp;capture2,</div><div class="line">    &amp;capture3,</div><div class="line">    &amp;capture4](<span class="keyword">const</span> T1&amp; p1, <span class="keyword">const</span> T2&amp; p2) {</div><div class="line">  ...;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// 3: Don&#39;t use.</span></div><div class="line"><span class="keyword">function</span>([&amp;capture1,</div><div class="line">          &amp;capture2,</div><div class="line">          &amp;capture3,</div><div class="line">          &amp;capture4](<span class="keyword">const</span> T1&amp; p1, <span class="keyword">const</span> T2&amp; p2) {</div><div class="line">  ...;</div><div class="line">});</div><div class="line"></div><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacelambda.html">lambda</a> = [&amp;capture1,</div><div class="line">               &amp;capture2,</div><div class="line">               &amp;capture3,</div><div class="line">               &amp;capture4](<span class="keyword">const</span> T1&amp; p1, <span class="keyword">const</span> T2&amp; p2) {</div><div class="line">  ...;</div><div class="line">  };</div><div class="line"></div><div class="line"><span class="comment">// 4: Don&#39;t use.</span></div><div class="line"><span class="keyword">function</span>([&amp;capture1,</div><div class="line">           &amp;capture2,</div><div class="line">           &amp;capture3,</div><div class="line">           &amp;capture4](</div><div class="line">    <span class="keyword">const</span> T1&amp; p1, <span class="keyword">const</span> T2&amp; p2, <span class="keyword">const</span> T3&amp; p3) {</div><div class="line">  ...;</div><div class="line">});</div><div class="line"></div><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacelambda.html">lambda</a> = [&amp;capture1,</div><div class="line">               &amp;capture2,</div><div class="line">               &amp;capture3,</div><div class="line">               &amp;capture4](</div><div class="line">    <span class="keyword">const</span> T1&amp; p1, <span class="keyword">const</span> T2&amp; p2, <span class="keyword">const</span> T3&amp; p3) {</div><div class="line">  ...;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// 5: Don&#39;t use.</span></div><div class="line"><span class="keyword">function</span>([&amp;capture1,</div><div class="line">          &amp;capture2,</div><div class="line">          &amp;capture3,</div><div class="line">          &amp;capture4](</div><div class="line">    <span class="keyword">const</span> T1&amp; p1,</div><div class="line">    <span class="keyword">const</span> T2&amp; p2,</div><div class="line">    <span class="keyword">const</span> T3&amp; p3) {</div><div class="line">  ...;</div><div class="line">  });</div><div class="line"></div><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacelambda.html">lambda</a> = [&amp;capture1,</div><div class="line">               &amp;capture2,</div><div class="line">               &amp;capture3,</div><div class="line">               &amp;capture4](</div><div class="line">    <span class="keyword">const</span> T1&amp; p1,</div><div class="line">    <span class="keyword">const</span> T2&amp; p2,</div><div class="line">    <span class="keyword">const</span> T3&amp; p3) {</div><div class="line">  ...;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// 6: OK (parameter list longer than 80 characters).</span></div><div class="line"><span class="keyword">function</span>([&amp;capture1, &amp;capture2, &amp;capture3](</div><div class="line">    <span class="keyword">const</span> T1&amp; p1,</div><div class="line">    <span class="keyword">const</span> T2&amp; p2,</div><div class="line">    <span class="keyword">const</span> T3&amp; p3,</div><div class="line">    <span class="keyword">const</span> T4&amp; p4) {</div><div class="line">  ...;</div><div class="line">});</div><div class="line"></div><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacelambda.html">lambda</a> = [&amp;capture1, &amp;capture2, &amp;capture3](</div><div class="line">    <span class="keyword">const</span> T1&amp; p1,</div><div class="line">    <span class="keyword">const</span> T2&amp; p2,</div><div class="line">    <span class="keyword">const</span> T3&amp; p3,</div><div class="line">    <span class="keyword">const</span> T4&amp; p4) {</div><div class="line">  ...;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// 7: OK (capture and parameter lists longer than 80 characters).</span></div><div class="line"><span class="keyword">function</span>([</div><div class="line">    &amp;capture1,</div><div class="line">    &amp;capture2,</div><div class="line">    &amp;capture3,</div><div class="line">    &amp;capture4](</div><div class="line">        <span class="keyword">const</span> T1&amp; p1,</div><div class="line">        <span class="keyword">const</span> T2&amp; p2,</div><div class="line">        <span class="keyword">const</span> T3&amp; p3,</div><div class="line">        <span class="keyword">const</span> T4&amp; p4) {</div><div class="line">  ...;</div><div class="line">});</div><div class="line"></div><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacelambda.html">lambda</a> = [</div><div class="line">    &amp;capture1,</div><div class="line">    &amp;capture2,</div><div class="line">    &amp;capture3,</div><div class="line">    &amp;capture4](</div><div class="line">        <span class="keyword">const</span> T1&amp; p1,</div><div class="line">        <span class="keyword">const</span> T2&amp; p2,</div><div class="line">        <span class="keyword">const</span> T3&amp; p3,</div><div class="line">        <span class="keyword">const</span> T4&amp; p4) {</div><div class="line">  ...;</div><div class="line">};</div></div><!-- fragment --><ul>
<li><p class="startli">Unrestricted Union.</p>
<p class="startli">Like the pre-existing <code>union</code>, we can overlap storage allocation for objects that never exist simultaneously. However, with C++11 we are no longer <em>restricted to having only non-POD types in unions</em>. Adding non-POD types to unions complicates things, however, because we need to make sure to properly call constructors and destructors. Therefore, only use unrestricted unions (i.e., unions with non-POD types) when the union has only a single field. What does this buy us? Now we can avoid dynamic memory allocations for "container" like types, e.g., <code><a class="el" href="classOption.html">Option</a></code>, <code><a class="el" href="classTry.html">Try</a></code>, <code><a class="el" href="classResult.html">Result</a></code>, etc. In effect, we treat the union like a dynamic allocation, calling <em>placement new</em>, <code>new (&amp;t) T(...)</code> anyplace we would have just called <code>new T(...)</code> and the destructor <code>t.~T()</code> anyplace we would have called <code>delete t</code>.</p>
</li>
<li><p class="startli">Constant expressions.</p>
<p class="startli">Constant expressions allow the declaration of static non-POD objects while eliminating the unpredictable runtime initialization and destruction issues normally encountered, helping eliminate macros and hard-coded literals without sacrificing performance and type safety. Changes which require converting from <code>constexpr</code> to <code>const</code> can propagate through the dependency tree requiring that dependent <code>constexpr</code> uses also be converted to <code>const</code>, hence we avoid using <code>constexpr</code> in complex functions.</p>
<p class="startli"><code>constexpr</code> behaves as a combination of <code>inline</code> and <code>const</code> and hence must be defined before use in another <code>constexpr</code>.</p>
<p class="startli">Prefer <code>constexpr</code> to <code>const</code> for all constant POD declarations, <code>constexpr</code> <code>char</code> arrays are preferred to <code>const</code> <code>string</code> literals.</p>
</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// OK</span></div><div class="line">constexpr <span class="keywordtype">char</span> LITERAL[] = <span class="stringliteral">&quot;value&quot;</span>;</div><div class="line"></div><div class="line"><span class="comment">// Not OK - not available at compile time for optimization and</span></div><div class="line"><span class="comment">// definition required in a separate compilation module.</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> LITERAL[];</div><div class="line"></div><div class="line"><span class="comment">// Not OK - uncertain initialization order, cannot be used in other</span></div><div class="line"><span class="comment">// constexpr statements.</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">string</span> LITERAL(<span class="stringliteral">&quot;value&quot;</span>);</div></div><!-- fragment --><p><code>constexpr</code> functions are evaluated at compile time if all their arguments are constant expressions. Otherwise they default to initialization at runtime. However <code>constexpr</code> functions are limited in that they cannot perform dynamic casts, memory allocation or calls to non-constexpr functions. Prefer <code>constexpr</code> over const inline functions.</p>
<div class="fragment"><div class="line">constexpr <span class="keywordtype">size_t</span> MIN = 200;</div><div class="line">constexpr <span class="keywordtype">size_t</span> <a class="code" href="namespacerouting_1_1diagnosis_1_1socket_1_1state.html#a642e2c8808920dc59493b0ba3f2850e1">MAX</a> = 1000;</div><div class="line">constexpr <span class="keywordtype">size_t</span> SPAN() { <span class="keywordflow">return</span> MAX-MIN; }</div><div class="line"><span class="keywordtype">int</span> array[SPAN()];</div></div><!-- fragment --><p>Const expression constructors allow object initialization at compile time provided that all the constructor arguments are <code>constexpr</code> and the constructor body is empty, i.e. all initialization is performed in the initialization list. Classes which provide <code>constexpr</code> constructors should normally also provide <code>constexpr</code> copy constructors to allow the class to be used in the return value from a <code>constexpr</code> function.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>C</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  constexpr C(<span class="keywordtype">int</span> _i) : i(_i) {};</div><div class="line">  constexpr C(<span class="keyword">const</span> C&amp; c) : i(c.i) {}</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> i;</div><div class="line">};</div></div><!-- fragment --><p>C++11 does not provide <code>constexpr string</code> or <code>constexpr</code> containers in the STL and hence <code>constexpr</code> cannot be used for any class using stout's <a class="el" href="classError.html">Error()</a> class. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
