<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Apache Mesos: app-framework-development-guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Mesos
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">app-framework-development-guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr/>
 <h2>layout: documentation </h2>
<h1>Framework Development Guide</h1>
<p>In this document we refer to Mesos applications as "frameworks".</p>
<p>See one of the example framework schedulers in <code>MESOS_HOME/src/examples/</code> to get an idea of what a Mesos framework scheduler and executor in the language of your choice looks like. <a href="https://github.com/mesosphere/RENDLER">RENDLER</a> provides example framework implementations in C++, Go, Haskell, Java, Python and Scala.</p>
<h2>Create your Framework Scheduler</h2>
<p>You can write a framework scheduler in C, C++, Java/Scala, or Python. Your framework scheduler should inherit from the <code>Scheduler</code> class (see API below). Your scheduler should create a SchedulerDriver (which will mediate communication between your scheduler and the Mesos master) and then call <code><a class="el" href="namespaceprocess_1_1internal.html#a7ab45b8fc1010b947a370e51b463e82f">SchedulerDriver.run()</a></code>.</p>
<h3>Scheduler API</h3>
<p>Declared in <code>MESOS_HOME/include/mesos/scheduler.hpp</code></p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Empty virtual destructor (necessary to instantiate subclasses).</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">virtual</span> ~Scheduler() {}</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Invoked when the scheduler successfully registers with a Mesos</span></div><div class="line"><span class="comment"> * master. A unique ID (generated by the master) used for</span></div><div class="line"><span class="comment"> * distinguishing this framework from others and MasterInfo</span></div><div class="line"><span class="comment"> * with the ip and port of the current master are provided as arguments.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> registered(SchedulerDriver* driver,</div><div class="line">                        <span class="keyword">const</span> FrameworkID&amp; frameworkId,</div><div class="line">                        <span class="keyword">const</span> MasterInfo&amp; masterInfo) = 0;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Invoked when the scheduler re-registers with a newly elected Mesos master.</span></div><div class="line"><span class="comment"> * This is only called when the scheduler has previously been registered.</span></div><div class="line"><span class="comment"> * MasterInfo containing the updated information about the elected master</span></div><div class="line"><span class="comment"> * is provided as an argument.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> reregistered(SchedulerDriver* driver,</div><div class="line">                          <span class="keyword">const</span> MasterInfo&amp; masterInfo) = 0;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Invoked when the scheduler becomes &quot;disconnected&quot; from the master</span></div><div class="line"><span class="comment"> * (e.g., the master fails and another is taking over).</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> disconnected(SchedulerDriver* driver) = 0;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Invoked when resources have been offered to this framework. A</span></div><div class="line"><span class="comment"> * single offer will only contain resources from a single slave.</span></div><div class="line"><span class="comment"> * Resources associated with an offer will not be re-offered to</span></div><div class="line"><span class="comment"> * _this_ framework until either (a) this framework has rejected</span></div><div class="line"><span class="comment"> * those resources (see SchedulerDriver::launchTasks) or (b) those</span></div><div class="line"><span class="comment"> * resources have been rescinded (see Scheduler::offerRescinded).</span></div><div class="line"><span class="comment"> * Note that resources may be concurrently offered to more than one</span></div><div class="line"><span class="comment"> * framework at a time (depending on the allocator being used). In</span></div><div class="line"><span class="comment"> * that case, the first framework to launch tasks using those</span></div><div class="line"><span class="comment"> * resources will be able to use them while the other frameworks</span></div><div class="line"><span class="comment"> * will have those resources rescinded (or if a framework has</span></div><div class="line"><span class="comment"> * already launched tasks with those resources then those tasks will</span></div><div class="line"><span class="comment"> * fail with a TASK_LOST status and a message saying as much).</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> resourceOffers(SchedulerDriver* driver,</div><div class="line">                            <span class="keyword">const</span> std::vector&lt;Offer&gt;&amp; offers) = 0;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Invoked when an offer is no longer valid (e.g., the slave was</span></div><div class="line"><span class="comment"> * lost or another framework used resources in the offer). If for</span></div><div class="line"><span class="comment"> * whatever reason an offer is never rescinded (e.g., dropped</span></div><div class="line"><span class="comment"> * message, failing over framework, etc.), a framework that attempts</span></div><div class="line"><span class="comment"> * to launch tasks using an invalid offer will receive TASK_LOST</span></div><div class="line"><span class="comment"> * status updates for those tasks (see Scheduler::resourceOffers).</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> offerRescinded(SchedulerDriver* driver,</div><div class="line">                            <span class="keyword">const</span> OfferID&amp; offerId) = 0;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Invoked when the status of a task has changed (e.g., a slave is</span></div><div class="line"><span class="comment"> * lost and so the task is lost, a task finishes and an executor</span></div><div class="line"><span class="comment"> * sends a status update saying so, etc). If implicit</span></div><div class="line"><span class="comment"> * acknowledgements are being used, then returning from this</span></div><div class="line"><span class="comment"> * callback _acknowledges_ receipt of this status update! If for</span></div><div class="line"><span class="comment"> * whatever reason the scheduler aborts during this callback (or</span></div><div class="line"><span class="comment"> * the process exits) another status update will be delivered (note,</span></div><div class="line"><span class="comment"> * however, that this is currently not true if the slave sending the</span></div><div class="line"><span class="comment"> * status update is lost/fails during that time). If explicit</span></div><div class="line"><span class="comment"> * acknowledgements are in use, the scheduler must acknowledge this</span></div><div class="line"><span class="comment"> * status on the driver.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> statusUpdate(SchedulerDriver* driver,</div><div class="line">                          <span class="keyword">const</span> TaskStatus&amp; <a class="code" href="namespaceproc.html#a34396c6140a28f583dc13fee3c3c35d4">status</a>) = 0;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Invoked when an executor sends a message. These messages are best</span></div><div class="line"><span class="comment"> * effort; do not expect a framework message to be retransmitted in</span></div><div class="line"><span class="comment"> * any reliable fashion.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> frameworkMessage(SchedulerDriver* driver,</div><div class="line">                              <span class="keyword">const</span> ExecutorID&amp; executorId,</div><div class="line">                              <span class="keyword">const</span> SlaveID&amp; slaveId,</div><div class="line">                              <span class="keyword">const</span> std::string&amp; data) = 0;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Invoked when a slave has been determined unreachable (e.g.,</span></div><div class="line"><span class="comment"> * machine failure, network partition). Most frameworks will need to</span></div><div class="line"><span class="comment"> * reschedule any tasks launched on this slave on a new slave.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> slaveLost(SchedulerDriver* driver,</div><div class="line">                       <span class="keyword">const</span> SlaveID&amp; slaveId) = 0;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Invoked when an executor has exited/terminated. Note that any</span></div><div class="line"><span class="comment"> * tasks running will have TASK_LOST status updates automagically</span></div><div class="line"><span class="comment"> * generated.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * NOTE: This callback is not reliably delivered.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> executorLost(SchedulerDriver* driver,</div><div class="line">                          <span class="keyword">const</span> ExecutorID&amp; executorId,</div><div class="line">                          <span class="keyword">const</span> SlaveID&amp; slaveId,</div><div class="line">                          <span class="keywordtype">int</span> <a class="code" href="namespaceproc.html#a34396c6140a28f583dc13fee3c3c35d4">status</a>) = 0;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Invoked when there is an unrecoverable error in the scheduler or</span></div><div class="line"><span class="comment"> * scheduler driver. The driver will be aborted BEFORE invoking this</span></div><div class="line"><span class="comment"> * callback.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> error(SchedulerDriver* driver, <span class="keyword">const</span> std::string&amp; message) = 0;</div></div><!-- fragment --><h3>Handling Failures</h3>
<p>How to build Mesos frameworks that remain available in the face of failures is discussed in a <a class="el" href="high-availability-framework-guide_8md.html">separate document</a>.</p>
<h2>Working with Executors</h2>
<h3>Using the Mesos Command Executor</h3>
<p>Mesos provides a simple executor that can execute shell commands and <a class="el" href="classDocker.html">Docker</a> containers on behalf of the framework scheduler; enough functionality for a wide variety of framework requirements.</p>
<p>Any scheduler can make use of the Mesos command executor by filling in the optional <code>CommandInfo</code> member of the <code>TaskInfo</code> protobuf message.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;message TaskInfo {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  ...</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  optional CommandInfo command = 7;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  ...</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div></div><!-- fragment --><p>The Mesos slave will fill in the rest of the ExecutorInfo for you when tasks are specified this way.</p>
<h3>Creating a custom Framework Executor</h3>
<p>If your framework has special requirements, you might want to provide your own Executor implementation. For example, you may not want a 1:1 relationship between tasks and processes.</p>
<p>Your framework executor must inherit from the Executor class. It must override the launchTask() method. You can use the $MESOS_HOME environment variable inside of your executor to determine where Mesos is running from.</p>
<h4>Executor API</h4>
<p>Declared in <code>MESOS_HOME/include/mesos/executor.hpp</code></p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Invoked once the executor driver has been able to successfully</span></div><div class="line"><span class="comment"> * connect with Mesos. In particular, a scheduler can pass some</span></div><div class="line"><span class="comment"> * data to it&#39;s executors through the FrameworkInfo.ExecutorInfo&#39;s</span></div><div class="line"><span class="comment"> * data field.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> registered(ExecutorDriver* driver,</div><div class="line">                        <span class="keyword">const</span> ExecutorInfo&amp; executorInfo,</div><div class="line">                        <span class="keyword">const</span> FrameworkInfo&amp; frameworkInfo,</div><div class="line">                        <span class="keyword">const</span> SlaveInfo&amp; slaveInfo) = 0;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Invoked when the executor re-registers with a restarted slave.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> reregistered(ExecutorDriver* driver,</div><div class="line">                          <span class="keyword">const</span> SlaveInfo&amp; slaveInfo) = 0;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Invoked when the executor becomes &quot;disconnected&quot; from the slave</span></div><div class="line"><span class="comment"> * (e.g., the slave is being restarted due to an upgrade).</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> disconnected(ExecutorDriver* driver) = 0;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Invoked when a task has been launched on this executor (initiated</span></div><div class="line"><span class="comment"> * via Scheduler::launchTasks). Note that this task can be realized</span></div><div class="line"><span class="comment"> * with a thread, a process, or some simple computation, however, no</span></div><div class="line"><span class="comment"> * other callbacks will be invoked on this executor until this</span></div><div class="line"><span class="comment"> * callback has returned.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> launchTask(ExecutorDriver* driver,</div><div class="line">                        <span class="keyword">const</span> TaskInfo&amp; task) = 0;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Invoked when a task running within this executor has been killed</span></div><div class="line"><span class="comment"> * (via SchedulerDriver::killTask). Note that no status update will</span></div><div class="line"><span class="comment"> * be sent on behalf of the executor, the executor is responsible</span></div><div class="line"><span class="comment"> * for creating a new TaskStatus (i.e., with TASK_KILLED) and</span></div><div class="line"><span class="comment"> * invoking ExecutorDriver::sendStatusUpdate.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> killTask(ExecutorDriver* driver, <span class="keyword">const</span> TaskID&amp; taskId) = 0;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Invoked when a framework message has arrived for this</span></div><div class="line"><span class="comment"> * executor. These messages are best effort; do not expect a</span></div><div class="line"><span class="comment"> * framework message to be retransmitted in any reliable fashion.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> frameworkMessage(ExecutorDriver* driver,</div><div class="line">                              <span class="keyword">const</span> std::string&amp; data) = 0;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Invoked when the executor should terminate all of it&#39;s currently</span></div><div class="line"><span class="comment"> * running tasks. Note that after a Mesos has determined that an</span></div><div class="line"><span class="comment"> * executor has terminated any tasks that the executor did not send</span></div><div class="line"><span class="comment"> * terminal status updates for (e.g., TASK_KILLED, TASK_FINISHED,</span></div><div class="line"><span class="comment"> * TASK_FAILED, etc) a TASK_LOST status update will be created.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="namespacemesos_1_1internal_1_1local.html#a7d7b8de28b47a3753dcd4b094d5e6c6e">shutdown</a>(ExecutorDriver* driver) = 0;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Invoked when a fatal error has occurred with the executor and/or</span></div><div class="line"><span class="comment"> * executor driver. The driver will be aborted BEFORE invoking this</span></div><div class="line"><span class="comment"> * callback.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> error(ExecutorDriver* driver, <span class="keyword">const</span> std::string&amp; message) = 0;</div></div><!-- fragment --><h4>Install your custom Framework Executor</h4>
<p>After creating your custom executor, you need to make it available to all slaves in the cluster.</p>
<p>One way to distribute your framework executor is to let the <a class="el" href="fetcher_8md.html">Mesos fetcher</a> download it on-demand when your scheduler launches tasks on that slave. <code>ExecutorInfo</code> is a <a class="el" href="structProtocol.html">Protocol</a> Buffer Message class (defined in <code>include/mesos/mesos.proto</code>), and it contains a field of type <code>CommandInfo</code>. <code>CommandInfo</code> allows schedulers to specify, among other things, a number of resources as URIs. These resources are fetched to a sandbox directory on the slave before attempting to execute the <code>ExecutorInfo</code> command. Several URI schemes are supported, including HTTP, FTP, <a class="el" href="classHDFS.html">HDFS</a>, and S3 (e.g. see src/examples/java/TestFramework.java for an example of this).</p>
<p>Alternatively, you can pass the <code>frameworks_home</code> configuration option (defaults to: <code>MESOS_HOME/frameworks</code>) to your <code>mesos-slave</code> daemons when you launch them to specify where your framework executors are stored (e.g. on an NFS mount that is available to all slaves), then use a relative path in <code>CommandInfo.uris</code>, and the slave will prepend the value of <code>frameworks_home</code> to the relative path provided.</p>
<p>Once you are sure that your executors are available to the mesos-slaves, you should be able to run your scheduler, which will register with the Mesos master, and start receiving resource offers!</p>
<h2>Labels</h2>
<p><code>Labels</code> can be found in the <code>FrameworkInfo</code>, <code>TaskInfo</code>, <code>DiscoveryInfo</code> and <code>TaskStatus</code> messages; framework and module writers can use Labels to tag and pass unstructured information around Mesos. Labels are free-form key-value pairs supplied by the framework scheduler or label decorator hooks. Below is the protobuf definitions of labels:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;optional Labels labels = 11;</div></div><!-- fragment --><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;/**</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160; * Collection of labels.</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160; */</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;message Labels {</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    repeated Label labels = 1;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;/**</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160; * Key, value pair used to store free form user-data.</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160; */</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;message Label {</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;  required string key = 1;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;  optional string value = 2;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;}</div></div><!-- fragment --><p>Labels are not interpreted by Mesos itself, but will be made available over master and slave state endpoints. Further more, the executor and scheduler can introspect labels on the TaskInfo and TaskStatus programmatically. Below is an example of how two label pairs (<code>"environment": "prod"</code> and <code>"bananas": "apples"</code>) can be fetched from the master state endpoint.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ curl http://master/state.json</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;...</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;{</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  &quot;executor_id&quot;: &quot;default&quot;,</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  &quot;framework_id&quot;: &quot;20150312-120017-16777343-5050-39028-0000&quot;,</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  &quot;id&quot;: &quot;3&quot;,</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  &quot;labels&quot;: [</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    {</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;      &quot;key&quot;: &quot;environment&quot;,</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;      &quot;value&quot;: &quot;prod&quot;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    },</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    {</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;      &quot;key&quot;: &quot;bananas&quot;,</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;      &quot;value&quot;: &quot;apples&quot;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    }</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;  ],</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;  &quot;name&quot;: &quot;Task 3&quot;,</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;  &quot;slave_id&quot;: &quot;20150312-115625-16777343-5050-38751-S0&quot;,</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;  &quot;state&quot;: &quot;TASK_FINISHED&quot;,</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;  ...</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;},</div></div><!-- fragment --><h2>Service discovery</h2>
<p>When your framework registers an executor or launches a task, it can provide additional information for service discovery. This information is stored by the Mesos master along with other imporant information such as the slave currently running the task. A service discovery system can programmatically retrieve this information in order to set up DNS entries, configure proxies, or update any consistent store used for service discovery in a Mesos cluster that runs multiple frameworks and multiple tasks.</p>
<p>The optional <code>DiscoveryInfo</code> message for <code>TaskInfo</code> and <code>ExecutorInfo</code> is declared in <code>MESOS_HOME/include/mesos/mesos.proto</code></p>
<pre class="fragment">message DiscoveryInfo {
  enum Visibility {
    FRAMEWORK = 0;
    CLUSTER = 1;
    EXTERNAL = 2;
  }

  required Visibility visibility = 1;
  optional string name = 2;
  optional string environment = 3;
  optional string location = 4;
  optional string version = 5;
  optional Ports ports = 6;
  optional Labels labels = 7;
}
</pre><p><code>Visibility</code> is the key parameter that instructs the service discovery system whether a service should be discoverable. We currently differentiate between three cases:</p>
<ul>
<li>a task should not be discoverable for anyone but its framework.</li>
<li>a task should be discoverable for all frameworks running on the Mesos cluster but not externally.</li>
<li>a task should be made discoverable broadly.</li>
</ul>
<p>Many service discovery systems provide additional features that manage the visibility of services (e.g., ACLs in proxy based systems, security extensions to DNS, VLAN or subnet selection). It is not the intended use of the visibility field to manage such features. When a service discovery system retrieves the task or executor information from the master, it can decide how to handle tasks without DiscoveryInfo. For instance, tasks may be made non discoverable to other frameworks (equivalent to <code>visibility=FRAMEWORK</code>) or discoverable to all frameworks (equivalent to <code>visibility=CLUSTER</code>).</p>
<p>The <code>name</code> field is a string that that provides the service discovery system with the name under which the task is discoverable. The typical use of the name field will be to provide a valid hostname. If name is not provided, it is up to the service discovery system to create a name for the task based on the name field in <code>taskInfo</code> or other information.</p>
<p>The <code>environment</code>, <code>location</code>, and <code>version</code> fields provide first class support for common attributes used to differentiate between similar services in large deployments. The <code>environment</code> may receive values such as <code>PROD/QA/DEV</code>, the <code>location</code> field may receive values like <code>EAST-US/WEST-US/EUROPE/AMEA</code>, and the <code>version</code> field may receive values like v2.0/v0.9. The exact use of these fields is up to the service discovery system.</p>
<p>The <code>ports</code> field allows the framework to identify the ports a task listens to and explicitly name the functionality they represent and the layer-4 protocol they use (TCP, UDP, or other). For example, a Cassandra task will define ports like <code>"7000,Cluster,TCP"</code>, <code>"7001,SSL,TCP"</code>, <code>"9160,Thrift,TCP"</code>, <code>"9042,Native,TCP"</code>, and <code>"7199,JMX,TCP"</code>. It is up to the service discovery system to use these names and protocol in appropriate ways, potentially combining them with the <code>name</code> field in DiscoveryInfo.</p>
<p>The <code>labels</code> field allows a framework to pass arbitrary labels to the service discovery system in the form of key/value pairs. Note that anything passed through this field is not guaranteed to be supported moving forward. Nevertheless, this field provides extensibility. Common uses of this field will allow us to identify use cases that require first class support. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
