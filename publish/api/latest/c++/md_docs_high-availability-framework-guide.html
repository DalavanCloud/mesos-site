<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Apache Mesos: high-availability-framework-guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Mesos
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">high-availability-framework-guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr/>
 <h2>layout: documentation </h2>
<h1>Designing Highly Available Mesos Frameworks</h1>
<p>A Mesos framework manages tasks. For a Mesos framework to be highly available, it must continue to manage tasks correctly in the presence of a variety of failure scenarios. The most common failure conditions that framework authors should consider include:</p>
<ul>
<li>The Mesos master that a framework scheduler is connected to might fail, for example by crashing or by losing network connectivity. If the master has been configured to use <a class="el" href="high-availability_8md.html">high-availability mode</a>, this will result in promoting another Mesos master replica to become the current leader. In this situation, the scheduler should re-register with the new master and ensure that task state is consistent.</li>
<li>The host where a framework scheduler is running might fail. To ensure that the framework remains available and can continue to schedule new tasks, framework authors should ensure that multiple copies of the scheduler run on different nodes, and that a backup copy is promoted to become the new leader when the previous leader fails. Mesos itself does not dictate how framework authors should handle this situation, although we provide some suggestions below. It can be useful to deploy multiple copies of your framework scheduler using a long-running task scheduler such as Apache Aurora or Marathon.</li>
<li>The host where a task is running might fail. Alternatively, the node itself might not have failed but the Mesos agent on the node might be unable to communicate with the Mesos master, e.g., due to a network partition.</li>
</ul>
<p>Note that more than one of these failures might occur simultaneously.</p>
<h2>Mesos Architecture</h2>
<p>Before discussing the specific failure scenarios outlined above, it is worth highlighting some aspects of how Mesos is designed that influence high availability:</p>
<ul>
<li>Mesos provides unreliable messaging between components by default: messages are delivered "at-most-once" (they might be dropped). Framework authors should expect that messages they send might not be received and be prepared to take appropriate corrective action. To detect that a message might be lost, frameworks typically use timeouts. For example, if a framework attempts to launch a task, that message might not be received by the Mesos master (e.g., due to a transient network failure). To address this, the framework scheduler should set a timeout after attempting to launch a new task. If the scheduler hasn't seen a status update for the new task before the timeout fires, it should take corrective action&mdash;for example, by performing <a class="el" href="reconciliation_8md.html">task state reconciliation</a>, and then launching a new copy of the task if necessary.<ul>
<li>In general, distributed systems cannot distinguish between "lost" messages and messages that are merely delayed. In the example above, the scheduler might see a status update for the first task launch attempt immediately <em>after</em> its timeout has fired and it has already begun taking corrective action. Scheduler authors should be aware of this possibility and program accordingly.</li>
<li>Mesos actually provides ordered (but unreliable) message delivery between any two pair of processes: for example, if a framework sends messages M1 and M2 to the master, the master might receive no messages, just M1, just M2, or M1 followed by M2 &ndash; it will <em>not</em> receive M2 followed by M1.</li>
<li>As a convenience for framework authors, Mesos provides reliable delivery of task status updates. The agent persists task status updates to disk and then forwards them to the master. The master sends status updates to the appropriate framework scheduler. When a scheduler acknowledges a status update, the master forwards the acknowledgment back to the agent, which allows the stored status update to be garbage collected. If the agent does not receive an acknowledgment for a task status update within a certain amount of time, it will repeatedly resend the status update to the master, which will again forward the update to the scheduler. Hence, task status updates will be delivered "at least once", assuming that the agent and the scheduler both remain available. To handle the fact that task status updates might be delivered more than once, it can be helpful to make the framework logic that processes them <a href="https://en.wikipedia.org/wiki/Idempotence">idempotent</a>.</li>
</ul>
</li>
<li>The Mesos master stores information about the active tasks and registered frameworks <em>in memory</em>: it does not persist it to disk or attempt to ensure that this information is preserved after a master failover. This helps the Mesos master scale to large clusters with many tasks and frameworks. A downside of this design is that after a failure, more work is required to recover the lost in-memory master state.</li>
<li>If all the Mesos masters are unavailable (e.g., crashed or unreachable), the cluster should continue to operate: existing Mesos agents and user tasks should continue running. However, new tasks cannot be scheduled, and frameworks will not receive resource offers or status updates about previously launched tasks.</li>
<li>Mesos does not dictate how frameworks should be implemented and does not try to assume responsibility for how frameworks should deal with failures. Instead, Mesos tries to provide framework developers with the tools they need to implement this behavior themselves. Different frameworks might choose to handle failures differently, depending on their exact requirements.</li>
</ul>
<h2>Recommendations for Highly Available Frameworks</h2>
<p>Highly available framework designs typically follow a few common patterns:</p>
<ol type="1">
<li>To tolerate scheduler failures, frameworks run multiple scheduler instances (three instances is typical). At any given time, only one of these scheduler instances is the <em>leader</em>: this instance is connected to the Mesos master, receives resource offers and task status updates, and launches new tasks. The other scheduler replicas are <em>followers</em>: they are used only when the leader fails, in which case one of the followers is chosen to become the new leader.</li>
<li>Schedulers need a mechanism to decide when the current scheduler leader has failed and to elect a new leader. This is typically accomplished using a coordination service like <a href="https://zookeeper.apache.org/">Apache ZooKeeper</a> or <a href="https://github.com/coreos/etcd">etcd</a>. Consult the documentation of the coordination system you are using for more information on how to correctly implement leader election.</li>
<li>After electing a new leading scheduler, the new leader needs to ensure that its local state is consistent with the current state of the cluster. For example, suppose that the previous leading scheduler attempted to launch a new task and then immediately failed. The task might have launched successfully, at which point the newly elected leader will begin to receive status updates about it. To handle this situation, frameworks typically use a strongly consistent distributed data store to record information about active and pending tasks. In fact, the same coordination service that is used for leader election (such as <a class="el" href="classZooKeeper.html">ZooKeeper</a> or etcd) can often be used for this purpose. Some Mesos frameworks (such as Apache Aurora) use the Mesos replicated log for this purpose.<ul>
<li>The data store should be used to record the actions that the scheduler <em>intends</em> to take, before it takes them. For example, if a scheduler decides to launch a new task, it <em>first</em> writes this intent to its data store. Then it sends a "launch task" message to the Mesos master. If this instance of the scheduler fails and a new scheduler is promoted to become the leader, the new leader can consult the data store to find <em>all possible tasks</em> that might be running on the cluster. This is an instance of the <a href="https://en.wikipedia.org/wiki/Write-ahead_logging">write-ahead logging</a> pattern often employed by database systems and filesystems to improve reliability. Two aspects of this design are worth emphasizing.<ol type="a">
<li>The scheduler must persist its intent <em>before</em> launching the task: if the task is launched first and then the scheduler fails before it can write to the data store, the new leading scheduler won't know about the new task. If this occurs, the new scheduler instance will begin receiving task status updates for a task that it has no knowledge of; there is often not a good way to recover from this situation.</li>
<li>Second, the scheduler should ensure that its intent has been durably recorded in the data store before continuing to launch the task (for example, it should wait for a quorum of replicas in the data store to have acknowledged receipt of the write operation). For more details on how to do this, consult the documentation for the data store you are using.</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2>The Life Cycle of a Task</h2>
<p>A Mesos task transitions through a sequence of states. The authoritative "source
of truth" for the current state of a task is the agent on which the task is running. A framework scheduler learns about the current state of a task by communicating with the Mesos master&mdash;specifically, by listening for task status updates and by performing task state reconciliation.</p>
<p>Frameworks can represent the state of a task using a state machine, with one initial state and several possible terminal states:</p>
<ul>
<li>A task begins in the <code>TASK_STAGING</code> state. A task is in this state when the master has received the framework's request to launch the task but the task has not yet started to run. In this state, the task's dependencies are fetched&mdash;for example, using the <a class="el" href="fetcher_8md.html">Mesos fetcher cache</a>.</li>
<li>The <code>TASK_STARTING</code> state is optional and intended primarily for use by custom executors. It can be used to describe the fact that a custom executor has learned about the task (and maybe started fetching its dependencies) but has not yet started to run it.</li>
<li>A task transitions to the <code>TASK_RUNNING</code> state after it starts running successfully (if the task fails to start, it transitions to one of the terminal states listed below).<ul>
<li>If a framework attempts to launch a task but does not receive a status update for it within a timeout, the framework should perform <a class="el" href="reconciliation_8md.html">reconciliation</a>. That is, it should ask the master for the current state of the task. The master will reply with <code>TASK_LOST</code> for unknown tasks. The framework can then use this to distinguish between tasks that are slow to launch and tasks that the master has never heard about (e.g., because the task launch message was dropped).<ul>
<li>Note that the correctness of this technique depends on the fact that messaging between the scheduler and the master is ordered.</li>
</ul>
</li>
</ul>
</li>
<li>There are several terminal states:<ul>
<li><code>TASK_FINISHED</code> is used when a task completes successfully.</li>
<li><code>TASK_FAILED</code> indicates that a task aborted with an error.</li>
<li><code>TASK_KILLED</code> indicates that a task was killed by the executor.</li>
<li><code>TASK_LOST</code> indicates that the task was running on an agent that has lost contact with the current master (typically due to a network partition or the agent host crashing). This case is described further below.</li>
<li><code>TASK_ERROR</code> indicates that a task launch attempt failed because of an error in the task specification.</li>
</ul>
</li>
</ul>
<h2>Dealing with Partitioned or Failed Agents</h2>
<p>The Mesos master keeps track of the availability and health of the registered agents by 2 different mechanisms.</p>
<p>1) State of a persistent TCP connection to the agent.</p>
<p>2) Health checks via periodic ping messages to the agent which are expected to be responded with pongs (this behavior is controlled by the <code>--slave_ping_timeout</code> and <code>--max_slave_ping_timeouts</code> master flags).</p>
<p>If the persistent TCP connection to the agent breaks or the agent fails health checks, the master decides that the agent has failed and takes steps to remove it from the cluster. Specifically:</p>
<ul>
<li>If the TCP connection breaks, the agent is considered disconnected. The semantics when a registered agent gets disconnected are as follows for each framework running on that agent:<ul>
<li>If the framework is <a class="el" href="slave-recovery_8md.html">checkpointing</a>: No immediate action is taken. The agent is given a chance to reconnect until health checks time out.</li>
<li>If the framework is not-checkpointing: All the framework's tasks and executors are considered lost. Master immediately sends <code>TASK_LOST</code> status updates for the tasks. These updates are not delivered reliably to the scheduler (see NOTE below). The agent is given a chance to reconnect until health checks timeout.</li>
</ul>
</li>
<li>If the agent fails health checks it is scheduled for removal. The removals can be rate limited by the master (see <code>---slave_removal_rate_limit</code> master flag) to avoid removing a slew of slaves at once (e.g., during a network partition event).</li>
<li>Once it is time to remove an agent, the master marks it as "removed" in the master's durable state (this will survive master failover). If an agent marked as "removed" attempts to reconnect to the master (e.g., after network partition is restored), the connection attempt will be refused and the agent asked to shutdown. A shutting down agent shuts down all running tasks and executors, but any persistent volumes and dynamic reservations are still preserved.<ul>
<li>To allow the removed agent node to rejoin the cluster, a new <code>mesos-slave</code> process can be started. This will ensure the agent receives a new agent ID and register with master possibly with previously created persistent volumes and dynamic reservations. In effect, the agent will be treated as a newly joined agent.</li>
</ul>
</li>
<li>For each agent that is marked "removed" the scheduler receives a <code>slaveLost</code> callback and <code>TASK_LOST</code> status updates for each task that was running on the agent <pre class="fragment">  &gt;NOTE: Neither the callback nor the updates are reliably delivered by the master. For example if
  the master or scheduler fails over or there is a network connection issue during the delivery
  of these messages, they will not be resent.
</pre></li>
</ul>
<p>Typically, frameworks respond to this situation by scheduling new copies of the tasks that were running on the lost agent. This should be done with caution, however: it is possible that the lost agent is still alive, but is partitioned from the master and is unable to communicate with it. Depending on the nature of the network partition, tasks on the agent might still be able to communicate with external clients or other hosts in the cluster. Frameworks can take steps to prevent this (e.g., by having tasks connect to <a class="el" href="classZooKeeper.html">ZooKeeper</a> and cease operation if their <a class="el" href="classZooKeeper.html">ZooKeeper</a> session expires), but Mesos leaves such details to framework authors.</p>
<h2>Dealing with Partitioned or Failed Masters</h2>
<p>The behavior described above does not apply during the period immediately after a new Mesos master is elected. As noted above, most Mesos master state is kept in-memory; hence, when the leading master fails and a new master is elected, the new master will have little knowledge of the current state of the cluster. Instead, it rebuilds this information as the frameworks and agents notice that a new master has been elected and then <em>reregister</em> with it.</p>
<h3>Framework Reregistration</h3>
<p>When master failover occurs, frameworks that were connected to the previous leading master should reconnect to the new leading master. The <code>MesosSchedulerDriver</code> handles most of the details of detecting when the previous leading master has failed and connecting to the new leader; when the framework has successfully reregistered with the new leading master, the <code>reregistered</code> scheduler callback will be invoked.</p>
<p>When a highly available framework scheduler initially connects to the master, it should set the <code>failover_timeout</code> field in its <code>FrameworkInfo</code>. This specifies how long the master will wait for a framework to reconnect after a failover before the framework's state is garbage-collected and any running tasks associated with the framework are killed. It is recommended that frameworks set a generous <code>failover_timeout</code> (e.g., 1 week) to avoid their tasks being killed unintentionally.</p>
<h3>Agent Reregistration</h3>
<p>During the period after a new master has been elected but before a given agent has reregistered or the <code>slave_reregister_timeout</code> has fired, attempting to reconcile the state of a task running on that agent will not return any information (because the master cannot accurately determine the state of the task).</p>
<p>If an agent does not reregister with the new master within a timeout (controlled by the <code>--slave_reregister_timeout</code> configuration flag), the master marks the agent as failed and follows the same steps described above. However, there is one difference: by default, agents are <em>allowed to reconnect</em> following master failover, even after the <code>slave_reregister_timeout</code> has fired. This means that frameworks might see a <code>TASK_LOST</code> update for a task but then later discover that the task is running (because the agent where it was running was allowed to reconnect). This behavior can be avoided by enabling the <code>--registry_strict</code> configuration flag, which will be the default in a future version of Mesos. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
