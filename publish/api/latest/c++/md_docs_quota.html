<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Apache Mesos: quota</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Mesos
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">quota </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr/>
 <h2>layout: documentation </h2>
<h1><a class="el" href="structQuota.html">Quota</a></h1>
<p>A problem when running multiple frameworks on Mesos is that the default <a href="https://www.cs.berkeley.edu/~alig/papers/drf.pdf">wDRF allocator</a> may offer resources to frameworks even though they are beyond their fair share (e.g., when no other framework currently accepts these resources). There is no mechanism to lay away resources for future consumption in an entire cluster. Even though <a class="el" href="reservation_8md.html">dynamic reservations</a> allow both operators and frameworks to dynamically reserve resources on particular Mesos agents, it does not solve the above problem because any individual agents might fail.</p>
<p>Since version 0.27.0 Mesos provides a mechanism to reserve a certain amount of resources in an entire cluster, i.e. not tied to a particular agent. <em><a class="el" href="structQuota.html">Quota</a></em> allows operators to lay away resources for a given <a class="el" href="roles_8md.html">role</a>. These resources cannot be hijacked by other roles and are guaranteed to be available for the role if there are enough resources in the cluster. <a class="el" href="structQuota.html">Quota</a> can be viewed as a cluster-wide dynamic reservation available for operators only.</p>
<h1>Terminology</h1>
<p>For the purpose of this document, an “Operator” is a person, tool, or script that manages the Mesos cluster.</p>
<p>In computer science, a “quota” usually refers to one of the following:</p><ul>
<li>A minimal guarantee.</li>
<li>A maximal limit.</li>
<li>A pair of both.</li>
</ul>
<p>In Mesos we understand quota as a <b>guaranteed</b> resource allocation that a role may rely on; in other words, a minimum share a role is entitled to receive.</p>
<h1>Motivation and Limitations</h1>
<p>Consider the following scenarios in a Mesos cluster to better understand what use-cases are supported by quota (and what are not).</p>
<h2>Scenario 1: Greedy Framework</h2>
<p>There are two frameworks in a cluster, each running in a separate role with equal weights: framework fA in role rA and framework fB in role rB. There is a single resource available in the cluster: 100 CPUs. fA consumes 10 CPUs and is idle (declines resource offers), while fB is greedy and accepts all offers it gets, hogging the remaining 90 CPUs. Without quota, though fA’s fair share is 50 CPUs it will not be able to make use of additional the 40 CPUs until some of fB’s tasks terminate.</p>
<h2>Scenario 2: Resources for a new Framework</h2>
<p>A greedy framework fB in role rB is currently the only framework in the cluster and it uses all available resources&mdash;100 CPUs. If a new framework fA in role rA joins the cluster, it will not receive its fair share of the cluster resources (50 CPUs) until some of fB’s tasks terminate.</p>
<p>To deal with Scenario 2, quota by itself is not a sufficient solution as it would be set after fB has started using all resources. Instead Scenario 2 requires either always keeping a pool of resources which are not offered or introducing preemption for running tasks.</p>
<h1>Operator HTTP Endpoint</h1>
<p>The master <code>/quota</code> HTTP endpoint enables operators to configure quotas. The endpoint currently offers a REST-like interface and supports the following operations:</p>
<ul>
<li><a href="#setRequest">Setting</a> a new quota with POST.</li>
<li><a href="#removeRequest">Removing</a> an existing quota with DELETE.</li>
<li><a href="#statusRequest">Querying</a> the currently set quota with GET.</li>
</ul>
<p>Currently it is not possible to update previously configured quotas. This means in order to update a quota for a given role, the operator has to remove the existing quota and then set a new one.</p>
<p>The endpoint can optionally use authentication and authorization. See the <a class="el" href="authentication_8md.html">authentication guide</a> for details.</p>
<p><a class="anchor" id="setRequest"></a> </p><h2><a class="el" href="classSet.html">Set</a></h2>
<p>The operator can set a new quota by sending an HTTP POST request to the <code>/quota</code> endpoint.</p>
<p>An example request to the quota endpoint could look like this (using the <a class="el" href="namespaceJSON.html">JSON</a> definitions below): </p><pre class="fragment">$ curl -d jsonMessageBody -X POST http://&lt;master-ip&gt;:&lt;port&gt;/quota
</pre><p>For example to set a quota of 12 CPUs and 6144 MB of RAM for <code>role1</code> the operator can use the following <code>jsonMessageBody</code>: </p><pre class="fragment">    {
      "role": "role1",
      "guarantee": [
        {
          "name": "cpus",
          "type": "SCALAR",
          "scalar": { "value": 12 }
        },
        {
          "name": "mem",
          "type": "SCALAR",
          "scalar": { "value": 6144 }
        }
      ]
    }
</pre><p>A set request is only valid for roles for which no quota is currently set. However if the master is configured without an explicit <a class="el" href="roles_8md.html">role whitelist</a> a set request can introduce new roles.</p>
<p>In order to bypass the <a href="#capacityHeuristic">capacity heuristic</a> check the operator should set an optional <code>force</code> field: </p><pre class="fragment">    {
      "force": true,
      "role": "role1",
      ...
    }
</pre><p>The operator will receive one of the following HTTP response codes:</p>
<ul>
<li><code>200 OK</code>: Success (the set request was successful).</li>
<li><code>400 BadRequest</code>: Invalid arguments (e.g., quota for role exists, invalid <a class="el" href="namespaceJSON.html">JSON</a>, non-scalar resources included).</li>
<li><code>401 Unauthorized</code>: Unauthenticated request.</li>
<li><code>403 Forbidden</code>: Unauthorized request.</li>
<li><code>409 Conflict</code>: The capacity heuristic check failed due to insufficient resources.</li>
</ul>
<p><a class="anchor" id="removeRequest"></a> </p><h2>Remove</h2>
<p>The operator can remove a previously set quota by sending an HTTP DELETE request to the <code>/quota/&lt;role&gt;</code> endpoint. For example the following command removes a previously set quota for <code>role1</code>: </p><pre class="fragment">$ curl -X DELETE http://&lt;master-ip&gt;:&lt;port&gt;/quota/role1
</pre><p>The operator will receive one of the following HTTP response codes:</p>
<ul>
<li><code>200 OK</code>: Success (the remove request was successful).</li>
<li><code>400 BadRequest</code>: Invalid arguments (e.g., removing a quota for a role which does not have any quota set).</li>
<li><code>401 Unauthorized</code>: Unauthenticated request.</li>
<li><code>403 Forbidden</code>: Unauthorized request.</li>
</ul>
<p><a class="anchor" id="statusRequest"></a> </p><h2>Status</h2>
<p>The operator can query the configured quotas by sending a HTTP GET request to the <code>/quota</code> endpoint. </p><pre class="fragment">$ curl -X GET http://&lt;master-ip&gt;:&lt;port&gt;/quota
</pre><p>The response message body includes a <a class="el" href="namespaceJSON.html">JSON</a> representation of the current quota status, for example: </p><pre class="fragment">    {
      "infos": [
        {
          "role": "role1",
          "guarantee": [
            {
              "name": "cpus",
              "role": "*",
              "type": "SCALAR",
              "scalar": { "value": 12 }
            },
            {
              "name": "mem",
              "role": "*",
              "type": "SCALAR",
              "scalar": { "value": 6144 }
            }
          ]
        }
      ]
    }
</pre><p>The operator will receive one of the following HTTP response codes:</p>
<ul>
<li><code>200 OK</code>: Success.</li>
<li><code>401 Unauthorized</code>: Unauthenticated request.</li>
</ul>
<h1>How does it work?</h1>
<p>There are several stages in the lifetime of a quota issued by operator. First the <a href="#requestProcessing">quota set request is handled by the master</a>, after that the <a href="#allocatorEnforcement">allocator enforces the quota</a>. Quotas can be <a href="#removeProcessing">removed</a> by the operator.</p>
<p>It is important to understand that the enforcement of quota depends on the allocator being used. A custom allocator could choose to handle quota in its own way or even to ignore quota. <b>The following section assumes the default <a href="https://www.cs.berkeley.edu/~alig/papers/drf.pdf">wDRF</a> allocator is used.</b></p>
<p>Be aware that setting quota may affect other frameworks in the cluster, because resources will be laid away and not offered to other frameworks. Also note, that quota is only applicable for scalar resources (e.g., it is not possible to set quota for port resources).</p>
<p><a class="anchor" id="requestProcessing"></a> </p><h2><a class="el" href="structQuota.html">Quota</a> Request Processing</h2>
<p>When an operator submits a quota set request via the master <code>/quota</code> HTTP endpoint, the following steps are triggered:</p>
<ol type="1">
<li><a class="el" href="authentication_8md.html">Authenticate</a> the HTTP request.</li>
<li>Parse and validate the request. See <a href="#setRequest">description of possible error codes</a>.</li>
<li><a class="el" href="authentication_8md.html">Authorize</a> the HTTP request if authorization is enabled.</li>
<li>Run the <a href="#capacityHeuristic">capacity heuristic</a> if not disabled by <a href="#setRequest">the <code>force</code> flag</a>.</li>
<li>Reliably store quota. See <a href="#failover">details on failover recovery</a>.</li>
<li><a href="#rescindOffers">Rescind outstanding offers</a>.</li>
</ol>
<p><a class="anchor" id="removeProcessing"></a> The quota remove request processing is simpler and triggers the following steps:</p>
<ol type="1">
<li><a class="el" href="authentication_8md.html">Authenticate</a> the HTTP request.</li>
<li>Validate the request. See <a href="#removeRequest">description of potential error codes</a>.</li>
<li><a class="el" href="authentication_8md.html">Authorize</a> the HTTP request if authorization is enabled.</li>
<li>Reliably remove quota.</li>
</ol>
<p><a class="anchor" id="capacityHeuristic"></a> </p><h3>Capacity Heuristic Check</h3>
<p>Misconfigured quota can render a cluster into a state where no offers are made to any frameworks. For example imagine an operator setting quota 1000 CPUs for a role <code>prosuction</code> (note the typo) in a cluster with a total capacity of 100 CPUs. In that case after the quota is accepted by the master, no offers will be made to any framework in any actual role (including <code>production</code>).</p>
<p>In order to prevent such extreme situations, the Mesos Master employs a capacity heuristic check that ensures a quota set request can reasonably be satisfied given the total cluster capacity. This heuristic tests whether the total quota, including the new request, does not exceed the sum of total non-statically-reserved cluster resources, i.e. the following inequality holds: </p><pre class="fragment">total resources - statically reserved &gt;= total quota + quota request
</pre><p>Please be advised that even if there are enough resources at the moment of this check, agents may terminate at any time, rendering the cluster incapable of satisfying the configured quotas.</p>
<p>A <a href="#setRequest"><code>force</code> flag</a> can be set to bypass this check. For example, this flag can be useful when the operator would like to configure a quota that exceeds the current cluster capacity, but they know that additional cluster resources will be added shortly.</p>
<p><a class="anchor" id="rescindOffers"></a> </p><h3>Rescinding Outstanding Offers</h3>
<p>When setting a new quota, the master rescinds outstanding offers. This avoids situations where the quota request cannot be satisfied by the remaining unoffered resources, but there are enough resources tied up in outstanding offers to frameworks that have not accepted them yet. Hence, we rescind outstanding offers with the following rules:</p>
<ul>
<li>Rescind at least as many resources as there are in the quota request.</li>
<li>If at least one offer is to be rescinded from an agent, all offers from this agent are rescinded. This is done in order to make the potential offer bigger, which increases the chances that a quota'ed framework will be able to use the offer.</li>
<li>Rescind offers from at least as many agents as there are frameworks in the role for which quota is being set. This enables (but does not guarantee, due to fair sharing) each framework in the role to receive an offer.</li>
</ul>
<p><a class="anchor" id="allocatorEnforcement"></a> </p><h2>Enforcement by wDRF Allocator</h2>
<p>The wDRF allocator first allocates (or lays away if offers are declined) resources to framework in roles with quota set. Once all quotas are satisfied, it proceeds with the standard wDRF for all frameworks.</p>
<p><b>NOTE:</b> A quota'ed role may not be allocated any unreserved non-revocable resources beyond its quota guarantee. If frameworks in the quota'ed role have not opted for revocable resources, they may stop getting offers once quota for the role is satisfied. In this case setting quota to any value that is less than the role's fair share may reduce the amount of resources offered to this role.</p>
<p><b>NOTE:</b> In Mesos 0.27 quota guarantee also serves as quota limit, i.e. once quota for the role is satisfied, frameworks in this role will not be offered any resources except those reserved for the role. This behavior aims to mitigate the absence of quota limit and will be changed in future releases.</p>
<p>If there are multiple frameworks in a role with quota set, the standard wDRF algorithm determines framework priority inside this role.</p>
<p>The default wDRF allocator considers only non-revocable resources as applicable towards quota.</p>
<p><a class="anchor" id="failover"></a> </p><h2>Failover</h2>
<p>If there is at least one role with quota set, the master failover recovery changes significantly. The reason for this is that during the recovery there is a period of time when not all agents have registered with the Master. Therefore it is impossible to reason about whether all quotas are satisfied.</p>
<p>To address this issue, if upon recovery any previously set quota are detected, the allocator enters recovery mode, during which the allocator <em>does not issue offers</em>. The recovery mode&mdash;and therefore offer suspension&mdash;ends when either:</p>
<ul>
<li>A certain amount of agents reregister (by default 80% of agents known before the failover), or</li>
<li>a timeout expires (by default 10 minutes).</li>
</ul>
<h1>Current Limitations</h1>
<ul>
<li>The quota set request does not allow specifying the granularity of the requested resources (e.g. 10 CPUs on a single node).</li>
<li>The quota set request does not allow to specify constraints (e.g. 2*5 cpus on disjoint nodes for an HA like setup).</li>
<li><a class="el" href="structQuota.html">Quota</a> is not allowed for the default role ‘*’ (see MESOS-3938).</li>
<li>Currently it is not possible to update previously configured quotas. See <a href="#setRequest">quota set request</a> for details. </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
