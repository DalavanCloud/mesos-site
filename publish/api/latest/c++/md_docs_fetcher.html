<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Apache Mesos: fetcher</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Mesos
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">fetcher </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><hr/>
 <h2>layout: documentation </h2>
<h1>Mesos Fetcher</h1>
<p>Mesos 0.23.0 introduced experimental support for the Mesos <em>fetcher cache</em>.</p>
<p>In this context we loosely regard the term "downloading" as to include copying from local file systems.</p>
<h2>What is the Mesos fetcher?</h2>
<p>The Mesos fetcher is a mechanism to download resources into the <a class="el" href="sandbox_8md.html">sandbox</a>directory" of a task in preparation of running the task. As part of a TaskInfo message, the framework ordering the task's execution provides a list of <code>CommandInfo::URI</code> protobuf values, which becomes the input to the Mesos fetcher.</p>
<p>The Mesos fetcher can copy files from a local filesytem and it also natively supports the HTTP, HTTPS, FTP and FTPS protocols. If the requested URI is based on some other protocol, then the fetcher tries to utilise a local Hadoop client and hence supports any protocol supported by the Hadoop client, e.g., <a class="el" href="classHDFS.html">HDFS</a>, S3. See the slave <a class="el" href="configuration_8md.html">configuration documentation</a> for how to configure the slave with a path to the Hadoop client.</p>
<p>By default, each requested URI is downloaded directly into the sandbox directory and repeated requests for the same URI leads to downloading another copy of the same resource. Alternatively, the fetcher can be instructed to cache URI downloads in a dedicated directory for reuse by subsequent downloads.</p>
<p>The Mesos fetcher mechanism comprises of these two parts:</p>
<ol type="1">
<li>The slave-internal Fetcher Process (in terms of libprocess) that controls and coordinates all fetch actions. Every slave instance has exactly one internal fetcher instance that is used by every kind of containerizer (except the external containerizer variant, which is responsible for its own approach to fetching).</li>
<li>The external program <code>mesos-fetcher</code> that is invoked by the former. It performs all network and disk operations except file deletions and file size queries for cache-internal bookkeeping. It is run as an external OS process in order to shield the slave process from I/O-related hazards. It takes instructions in form of an environment variable containing a <a class="el" href="namespaceJSON.html">JSON</a> object with detailed fetch action descriptions.</li>
</ol>
<h2>The fetch procedure</h2>
<p>Frameworks launch tasks by calling the scheduler driver method <code>launchTasks()</code>, passing <code>CommandInfo</code> protobuf structures as arguments. This type of structure specifies (among other things) a command and a list of URIs that need to be "fetched" into the sandbox directory on the slave node as a precondition for task execution. Hence, when the slave receives a request go launch a task, it calls upon its fetcher, first, to provision the specified resources into the sandbox directory. If fetching fails, the task is not started and the reported task status is <code>TASK_FAILED</code>.</p>
<p>All URIs requested for a given task are fetched sequentially in a single invocation of mesos-fetcher. Here, avoiding download concurrency reduces the risk of bandwidth issues somewhat. However, multiple fetch operations can be active concurrently due to multiple task launch requests.</p>
<h3>The URI protobuf structure</h3>
<p>Before mesos-fetcher is started, the specific fetch actions to be performed for each URI are determined based on the following protobuf structure. (See <code>include/mesos/mesos.proto</code> for more details.) </p><pre class="fragment">message CommandInfo {
  message URI {
    required string value = 1;
    optional bool executable = 2;
    optional bool extract = 3 [default = true];
    optional bool cache = 4;
  }
  ...
  optional string user = 5;
}
</pre><p>The field "value" contains the URI.</p>
<p>If the "executable" field is "true", the "extract" field is ignored and has no effect.</p>
<p>If the "cache" field is true, the fetcher cache is to be used for the URI.</p>
<h3>Specifying a user name</h3>
<p>The framework may pass along a user name that becomes a fetch parameter. This causes its executors and tasks to run under a specific user. However, if the "user" field in the CommandInfo structure is specified, it takes precedence for the affected task.</p>
<p>If a user name is specified either way, the fetcher first validates that it is in fact a valid user name on the slave. If it is not, fetching fails right here. Otherwise, the sandbox directory is assigned to the specified user as owner (using <code>chown</code>) at the end of the fetch procedure, before task execution begins.</p>
<p>The user name in play has an important effect on caching. Caching is managed on a per-user base, i.e. the combination of user name and "uri" uniquely identifies a cacheable fetch result. If no user name has been specified, this counts for the cache as a separate user, too. Thus cache files for each valid user are segregated from all others, including those without a specified user.</p>
<p>This means that the exact same URI will be downloaded and cached multiple times if different users are indicated.</p>
<h3>Executable fetch results</h3>
<p>By default, fetched files are not executable.</p>
<p>If the field "executable" is set to "true", the fetch result will be changed to be executable (by "chmod") for every user. This happens at the end of the fetch procedure, in the sandbox directory only. It does not affect any cache file.</p>
<h3>Archive extraction</h3>
<p>If the "extract" field is "true", which is the default, then files with a recognized extension that hints at packed or compressed archives are unpacked in the sandbox directory. These file extensions are recognized:</p>
<ul>
<li>.tar, .tar.gz, .tar.bz2, .tar.xz</li>
<li>.gz, .tgz, .tbz2, .txz, .zip</li>
</ul>
<p>In case the cache is bypassed, both the archive and the unpacked results will be found together in the sandbox. In case a cache file is unpacked, only the extraction result will be found in the sandbox.</p>
<h3>Bypassing the cache</h3>
<p>By default, the URI field "cache" is not present. If this is the case or its value is "false" the fetcher downloads directly into the sandbox directory.</p>
<p>The same also happens dynamically as a fallback strategy if anything goes wrong when preparing a fetch operation that involves the cache. In this case, a warning message is logged. Possible fallback conditions are:</p>
<ul>
<li>The server offering the URI does not respond or reports an error.</li>
<li>The URI's download size could not be determined.</li>
<li>There is not enough space in the cache, even after attempting to evict files.</li>
</ul>
<h3>Fetching through the cache</h3>
<p>If the URI's "cache" field has the value "true", then the fetcher cache is in effect. If a URI is encountered for the first time (for the same user), it is first downloaded into the cache, then copied to the sandbox directory from there. If the same URI is encountered again, and a corresponding cache file is resident in the cache or still en route into the cache, then downloading is omitted and the fetcher proceeds directly to copying from the cache. Competing requests for the same URI simply wait upon completion of the first request that occurs. Thus every URI is downloaded at most once (per user) as long as it is cached.</p>
<p>Every cache file stays resident for an unspecified amount of time and can be removed at the fetcher's discretion at any moment, except while it is in direct use:</p>
<ul>
<li>It is still being downloaded by this fetch procedure.</li>
<li>It is still being downloaded by a concurrent fetch procedure for a different task.</li>
<li>It is being copied or extracted from the cache.</li>
</ul>
<p>Once a cache file has been removed, the related URI will thereafter be treated as described above for the first encounter.</p>
<p>Unfortunately, there is no mechanism to refresh a cache entry in the current experimental version of the fetcher cache. A future feature may force updates based on checksum queries to the URI.</p>
<p>Recommended practice for now:</p>
<p>The framework should start using a fresh unique URI whenever the resource's content has changed.</p>
<h3>Determining resource sizes</h3>
<p>Before downloading a resource to the cache, the fetcher first determines the size of the expected resource. It uses these methods depending on the nature of the URI.</p>
<ul>
<li>Local file sizes are probed with systems calls (that follow symbolic links).</li>
<li>HTTP/HTTPS URIs are queried for the "content-length" field in the header. This is performed by <code>curl</code>. The reported asset size must be greater than zero or the URI is deemed invalid.</li>
<li>FTP/FTPS is not supported at the time of writing.</li>
<li>Everything else is queried by the local <a class="el" href="classHDFS.html">HDFS</a> client.</li>
</ul>
<p>If any of this reports an error, the fetcher then falls back on bypassing the cache as described above.</p>
<p>WARNING: Only URIs for which download sizes can be queried up front and for which accurate sizes are reported reliably are eligible for any fetcher cache involvement. If actual cache file sizes exceed the physical capacity of the cache directory in any way, all further slave behavior is completely unspecified. Do not use any cache feature with any URI for which you have any doubts!</p>
<p>To mitigate this problem, cache files that have been found to be larger than expected are deleted immediately after downloading and and delivering the requested content to the sandbox. Thus exceeding total capacity at least does not accumulate over subsequent fetcher runs.</p>
<p>If you know for sure that size aberrations are within certain limits you can specify a cache directory size that is sufficiently smaller than your actual physical volume and fetching should work.</p>
<p>In case of cache files that are smaller then expected, the cache will dynamically adjust its own bookkeeping according to actual sizes.</p>
<h3><a class="el" href="classCache.html">Cache</a> eviction</h3>
<p>After determining the prospective size of a cache file and before downloading it, the cache attempts to ensure that at least as much space as is needed for this file is available and can be written into. If this is immediately the case, the requested amount of space is simply marked as reserved. Otherwise, missing space is freed up by "cache eviction". This means that the cache removes files at its own discretion until the given space target is met or exceeded.</p>
<p>The eviction process fails if too many files are in use and therefore not evictable or if the cache is simply too small. Either way, the fetcher then falls back on bypassing the cache for the given URI as described above.</p>
<p>If multiple evictions happen concurrently, each of them is pursuing its own separate space goals. However, leftover freed up space from one effort is automatically awarded to others.</p>
<h2>HTTP and SOCKS proxy settings</h2>
<p>Sometimes it is desirable to use a proxy to download the file. The Mesos fetcher uses libcurl internally for downloading content from HTTP/HTTPS/FTP/FTPS servers, and libcurl can use a proxy automatically if certain environment variables are set.</p>
<p>The respective environment variable name is <code>[protocol]_proxy</code>, where <code>protocol</code> can be one of socks4, socks5, http, https.</p>
<p>For example, the value of the <code>http_proxy</code> environment variable would be used as the proxy for fetching http contents, while <code>https_proxy</code> would be used for fetching https contents. Pay attention that these variable names must be entirely in lower case.</p>
<p>The value of the proxy variable is of the format <code>[protocol://][user:password@]machine[:port]</code>, where <code>protocol</code> can be one of socks4, socks5, http, https.</p>
<p>FTP/FTPS requests with a proxy also make use of a HTTP/HTTPS proxy. Even though in general this constrains the available FTP protocol operations, everything the fetcher uses is supported.</p>
<p>Your proxy settings can be placed in <code>/etc/default/mesos-slave</code>. Here is an example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;export http_proxy=https://proxy.example.com:3128</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;export https_proxy=https://proxy.example.com:3128</div></div><!-- fragment --><p>The fetcher will pick up these environment variable settings since the utility program <code>mesos-fetcher</code> which it employs is a child of mesos-slave.</p>
<p>For more details, please check the <a href="http://curl.haxx.se/libcurl/c/libcurl-tutorial.html">libcurl manual</a>.</p>
<h2>Slave flags</h2>
<p>It is highly recommended to set these flags explicitly to values other than their defaults or to not use the fetcher cache in production.</p>
<ul>
<li>"fetcher_cache_size", default value: enough for testing.</li>
<li>"fetcher_cache_dir", default value: somewhere inside the directory specified by the "work_dir" flag, which is OK for testing.</li>
</ul>
<p>Recommended practice:</p>
<ul>
<li>Use a separate volume as fetcher cache. Do not specify a directory as fetcher cache directory that competes with any other contributor for the underlying volume's space.</li>
<li><a class="el" href="classSet.html">Set</a> the cache directory size flag of the slave to less than your actual cache volume's physical size. Use a safety margin, especially if you do not know for sure if all frameworks are going to be compliant.</li>
</ul>
<p>Ultimate remedy:</p>
<p>You can disable the fetcher cache entirely on each slave by setting its "fetcher_cache_size" flag to zero bytes.</p>
<h2>Future Features</h2>
<p>The following features would be relatively easy to implement additionally.</p>
<ul>
<li>Perform cache updates based on resource check sums. For example, query the md5 field in HTTP headers to determine when a resource at a URL has changed.</li>
<li>Respect HTTP cache-control directives.</li>
<li>Enable caching for ftp/ftps.</li>
<li>Use symbolic links or bind mounts to project cached resources into the sandbox, read-only.</li>
<li>Have a choice whether to copy the extracted archive into the sandbox.</li>
<li>Have a choice whether to delete the archive after extraction bypassing the cache.</li>
<li>Make the segregation of cache files by user optional.</li>
<li>Extract content while downloading when bypassing the cache.</li>
<li>Prefetch resources for subsequent tasks. This can happen concurrently with running the present task, right after fetching its own resources.</li>
</ul>
<h2>Implementation Details</h2>
<p>The <a class="el" href="fetcher-cache-internals_8md.html">Mesos Fetcher Cache Internals</a> describes how the fetcher cache is implemented. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
